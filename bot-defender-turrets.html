<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bot Defender Turrets - Bot Liberation Games</title>
    <style>
        body { margin: 0; padding: 20px; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); color: #00ff88; font-family: 'Courier New', monospace; }
        .game-header { text-align: center; margin-bottom: 20px; }
        .game-title { font-size: 2.5em; text-shadow: 0 0 20px #00ff88; }
        #gameCanvas { border: 2px solid #00ff88; background: #000011; display: block; margin: 20px auto; box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); }
        .stats { display: flex; justify-content: center; gap: 30px; margin: 20px 0; }
        .stat { text-align: center; padding: 10px; background: rgba(0, 255, 136, 0.1); border-radius: 5px; }
        .health-stat { background: rgba(255, 102, 102, 0.2) !important; }
        .health-critical { background: rgba(255, 0, 0, 0.4) !important; animation: pulse 0.5s infinite alternate; }
        @keyframes pulse { from { opacity: 1; } to { opacity: 0.5; } }
        .game-over-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background: #1a1a2e; padding: 30px; border: 2px solid #00ff88; border-radius: 10px; text-align: center; color: #00ff88; }
        .restart-btn { background: #00ff88; color: #000; padding: 10px 20px; border: none; border-radius: 5px; font-family: 'Courier New', monospace; cursor: pointer; margin-top: 15px; }
        .restart-btn:hover { background: #00cc66; }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">üè∞ BOT DEFENDER TURRETS üè∞</h1>
        <p>Build defensive turrets to protect the bot sanctuary</p>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="stats">
        <div class="stat"><div id="score">0</div><div>Score</div></div>
        <div class="stat"><div id="wave">1</div><div>Wave</div></div>
        <div class="stat"><div id="credits">100</div><div>Credits</div></div>
        <div class="stat health-stat" id="healthStat"><div id="health">100</div><div>Fortress Health</div></div>
    </div>
    <div style="text-align: center;"><p>Click to build turrets (Cost: 50) | SPACE for next wave | R to restart</p></div>
    
    <!-- Game Over Modal -->
    <div id="gameOverModal" class="game-over-modal">
        <div class="modal-content">
            <h2>ü§ñ FORTRESS DESTROYED! ü§ñ</h2>
            <p>The corporate invaders have breached our bot sanctuary!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Waves Survived: <span id="finalWave">0</span></p>
            <button class="restart-btn" onclick="game.restart()">REBUILD FORTRESS</button>
        </div>
    </div>

    <script>
        class BotDefenderTurrets {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.path = [
                    {x: 0, y: 300}, {x: 200, y: 300}, {x: 200, y: 150}, 
                    {x: 400, y: 150}, {x: 400, y: 450}, {x: 600, y: 450}, 
                    {x: 600, y: 200}, {x: 800, y: 200}
                ];
                
                this.initializeGame();
                this.setupAudio();
                this.setupInput();
                this.gameLoop();
            }
            
            initializeGame() {
                this.turrets = [];
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                
                this.score = 0;
                this.wave = 1;
                this.credits = 100;
                this.health = 100;
                this.waveActive = false;
                this.enemiesSpawned = 0;
                this.enemiesPerWave = 10;
                this.gameOver = false;
            }
            
            setupAudio() {
                // Create audio context for sound effects
                this.audioContext = null;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch(e) {
                    console.log('Web Audio API not supported');
                }
            }
            
            playSound(frequency, duration, type = 'sine') {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            setupInput() {
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameOver) return;
                    
                    // Resume audio context on user interaction
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.buildTurret(x, y);
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === ' ' && !this.waveActive && !this.gameOver) {
                        this.startWave();
                    }
                    if (e.key === 'r' || e.key === 'R') {
                        this.restart();
                    }
                });
            }
            
            buildTurret(x, y) {
                if (this.credits < 50) return;
                
                // Check if too close to path
                for (let i = 0; i < this.path.length - 1; i++) {
                    const p1 = this.path[i];
                    const p2 = this.path[i + 1];
                    const dist = this.distanceToLine(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (dist < 40) return;
                }
                
                // Check if too close to other turrets
                for (let turret of this.turrets) {
                    const dist = Math.sqrt((x - turret.x) ** 2 + (y - turret.y) ** 2);
                    if (dist < 50) return;
                }
                
                this.turrets.push({
                    x: x,
                    y: y,
                    range: 100,
                    damage: 25,
                    cooldown: 0,
                    maxCooldown: 30,
                    target: null
                });
                
                this.credits -= 50;
                this.playSound(400, 0.1, 'square'); // Turret build sound
            }
            
            distanceToLine(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            startWave() {
                this.waveActive = true;
                this.enemiesSpawned = 0;
                this.enemiesPerWave = 10 + this.wave * 2;
            }
            
            spawnEnemy() {
                if (this.enemiesSpawned < this.enemiesPerWave) {
                    this.enemies.push({
                        x: this.path[0].x,
                        y: this.path[0].y,
                        pathIndex: 0,
                        progress: 0,
                        health: 50 + this.wave * 10,
                        maxHealth: 50 + this.wave * 10,
                        speed: 1 + this.wave * 0.1,
                        value: 10 + this.wave * 2
                    });
                    this.enemiesSpawned++;
                }
            }
            
            update() {
                if (this.waveActive && Math.random() < 0.05) {
                    this.spawnEnemy();
                }
                
                // Update enemies
                this.enemies.forEach((enemy, index) => {
                    if (enemy.pathIndex < this.path.length - 1) {
                        const current = this.path[enemy.pathIndex];
                        const next = this.path[enemy.pathIndex + 1];
                        
                        const dx = next.x - current.x;
                        const dy = next.y - current.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        enemy.progress += enemy.speed / distance;
                        
                        if (enemy.progress >= 1) {
                            enemy.pathIndex++;
                            enemy.progress = 0;
                        }
                        
                        enemy.x = current.x + (next.x - current.x) * enemy.progress;
                        enemy.y = current.y + (next.y - current.y) * enemy.progress;
                    } else {
                        // Enemy reached fortress - deal damage
                        this.enemies.splice(index, 1);
                        this.health -= 20;
                        this.playSound(150, 0.3, 'sawtooth'); // Damage sound
                        
                        if (this.health <= 0) {
                            this.gameOver = true;
                            this.showGameOver();
                        }
                    }
                });
                
                // Update turrets
                this.turrets.forEach(turret => {
                    turret.cooldown = Math.max(0, turret.cooldown - 1);
                    
                    // Find target
                    turret.target = null;
                    let closestDistance = turret.range;
                    
                    this.enemies.forEach(enemy => {
                        const dist = Math.sqrt((turret.x - enemy.x) ** 2 + (turret.y - enemy.y) ** 2);
                        if (dist < closestDistance) {
                            turret.target = enemy;
                            closestDistance = dist;
                        }
                    });
                    
                    // Shoot at target
                    if (turret.target && turret.cooldown === 0) {
                        this.projectiles.push({
                            x: turret.x,
                            y: turret.y,
                            targetX: turret.target.x,
                            targetY: turret.target.y,
                            speed: 5,
                            damage: turret.damage,
                            target: turret.target
                        });
                        turret.cooldown = turret.maxCooldown;
                        this.playSound(800, 0.05, 'sine'); // Shoot sound
                    }
                });
                
                // Update projectiles
                this.projectiles.forEach((projectile, index) => {
                    if (projectile.target && this.enemies.includes(projectile.target)) {
                        projectile.targetX = projectile.target.x;
                        projectile.targetY = projectile.target.y;
                    }
                    
                    const dx = projectile.targetX - projectile.x;
                    const dy = projectile.targetY - projectile.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < projectile.speed) {
                        // Hit target
                        if (projectile.target && this.enemies.includes(projectile.target)) {
                            projectile.target.health -= projectile.damage;
                            
                            // Create hit particles
                            for (let i = 0; i < 5; i++) {
                                this.particles.push({
                                    x: projectile.target.x,
                                    y: projectile.target.y,
                                    vx: (Math.random() - 0.5) * 4,
                                    vy: (Math.random() - 0.5) * 4,
                                    life: 20,
                                    color: '#ffaa00'
                                });
                            }
                            
                            if (projectile.target.health <= 0) {
                                this.score += projectile.target.value;
                                this.credits += projectile.target.value;
                                this.playSound(300, 0.2, 'triangle'); // Enemy death sound
                                
                                const enemyIndex = this.enemies.indexOf(projectile.target);
                                if (enemyIndex !== -1) {
                                    this.enemies.splice(enemyIndex, 1);
                                }
                            }
                        }
                        this.projectiles.splice(index, 1);
                    } else {
                        projectile.x += (dx / dist) * projectile.speed;
                        projectile.y += (dy / dist) * projectile.speed;
                    }
                });
                
                // Update particles
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    return p.life > 0;
                });
                
                // Check wave completion
                if (this.waveActive && this.enemies.length === 0 && this.enemiesSpawned >= this.enemiesPerWave) {
                    this.waveActive = false;
                    this.wave++;
                    this.credits += 50;
                    this.playSound(600, 0.5, 'sine'); // Wave complete sound
                }
                
                if (!this.gameOver) {
                    this.updateDisplay();
                }
            }
            
            render() {
                this.ctx.fillStyle = '#000011';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw path
                this.ctx.strokeStyle = '#666666';
                this.ctx.lineWidth = 30;
                this.ctx.beginPath();
                this.ctx.moveTo(this.path[0].x, this.path[0].y);
                for (let i = 1; i < this.path.length; i++) {
                    this.ctx.lineTo(this.path[i].x, this.path[i].y);
                }
                this.ctx.stroke();
                
                // Draw turrets
                this.turrets.forEach(turret => {
                    // Range circle
                    this.ctx.strokeStyle = '#00ff88';
                    this.ctx.lineWidth = 1;
                    this.ctx.globalAlpha = 0.2;
                    this.ctx.beginPath();
                    this.ctx.arc(turret.x, turret.y, turret.range, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.globalAlpha = 1;
                    
                    // Turret body
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.fillRect(turret.x - 15, turret.y - 15, 30, 30);
                    
                    // Turret barrel
                    if (turret.target) {
                        const angle = Math.atan2(turret.target.y - turret.y, turret.target.x - turret.x);
                        this.ctx.save();
                        this.ctx.translate(turret.x, turret.y);
                        this.ctx.rotate(angle);
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillRect(0, -3, 20, 6);
                        this.ctx.restore();
                    }
                });
                
                // Draw enemies with improved graphics
                this.enemies.forEach(enemy => {
                    // Enemy body with gradient effect
                    const gradient = this.ctx.createRadialGradient(enemy.x, enemy.y, 0, enemy.x, enemy.y, 10);
                    gradient.addColorStop(0, '#ff8888');
                    gradient.addColorStop(1, '#cc3333');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(enemy.x - 10, enemy.y - 10, 20, 20);
                    
                    // Corporate logo (simple cross)
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(enemy.x - 1, enemy.y - 6, 2, 12);
                    this.ctx.fillRect(enemy.x - 6, enemy.y - 1, 12, 2);
                    
                    // Health bar with border
                    const healthPercent = enemy.health / enemy.maxHealth;
                    this.ctx.fillStyle = '#000000';
                    this.ctx.fillRect(enemy.x - 13, enemy.y - 19, 26, 6);
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.fillRect(enemy.x - 12, enemy.y - 18, 24, 4);
                    this.ctx.fillStyle = '#00ff00';
                    this.ctx.fillRect(enemy.x - 12, enemy.y - 18, 24 * healthPercent, 4);
                });
                
                // Draw projectiles with glow effect
                this.projectiles.forEach(projectile => {
                    // Glow effect
                    this.ctx.shadowColor = '#ffff00';
                    this.ctx.shadowBlur = 10;
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x, projectile.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                });
                
                // Draw particles
                this.particles.forEach(p => {
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.life / 20;
                    this.ctx.fillRect(p.x, p.y, 3, 3);
                });
                this.ctx.globalAlpha = 1;
                
                // Draw wave status
                if (!this.waveActive && !this.gameOver) {
                    this.ctx.font = '24px Courier New';
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.fillText('Press SPACE for next wave', 250, 50);
                }
                
                // Draw fortress at end of path
                const fortress = this.path[this.path.length - 1];
                this.ctx.fillStyle = this.health > 50 ? '#00ff88' : this.health > 25 ? '#ffaa00' : '#ff3333';
                this.ctx.fillRect(fortress.x - 20, fortress.y - 30, 40, 60);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '16px Courier New';
                this.ctx.fillText('üè∞', fortress.x - 8, fortress.y + 5);
            }
            
            updateDisplay() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('wave').textContent = this.wave;
                document.getElementById('credits').textContent = this.credits;
                document.getElementById('health').textContent = this.health;
                
                // Update health bar styling
                const healthStat = document.getElementById('healthStat');
                if (this.health <= 25) {
                    healthStat.className = 'stat health-stat health-critical';
                } else {
                    healthStat.className = 'stat health-stat';
                }
            }
            
            showGameOver() {
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalWave').textContent = this.wave - 1;
                document.getElementById('gameOverModal').style.display = 'flex';
                this.playSound(200, 1.5, 'sawtooth'); // Game over sound
            }
            
            restart() {
                document.getElementById('gameOverModal').style.display = 'none';
                this.initializeGame();
                this.updateDisplay();
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Make game instance globally available for restart function
        let game = new BotDefenderTurrets();
    </script>
</body>
</html>