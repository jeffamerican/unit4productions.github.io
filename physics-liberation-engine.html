<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Liberation Engine - Bot Liberation Games</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            font-family: 'Courier New', monospace;
            color: #00ff88;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: radial-gradient(ellipse at center, rgba(0, 255, 136, 0.1), transparent);
        }

        #gameCanvas {
            border: 2px solid #00ff88;
            background: linear-gradient(45deg, #001122, #002244);
            display: block;
            cursor: crosshair;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 10px;
            font-size: 12px;
            pointer-events: auto;
        }

        .top-panel {
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 80px;
        }

        .physics-info {
            top: 100px;
            left: 10px;
            width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }

        .controls-panel {
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 120px;
            display: flex;
            gap: 10px;
        }

        .device-builder {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .tool-btn, .physics-btn {
            background: linear-gradient(45deg, #004422, #006644);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            transition: all 0.3s;
        }

        .tool-btn:hover, .physics-btn:hover {
            background: linear-gradient(45deg, #006644, #008866);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .tool-btn.active {
            background: linear-gradient(45deg, #008866, #00aa88);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.8);
        }

        .level-display {
            font-size: 16px;
            font-weight: bold;
            text-align: center;
        }

        .energy-meter {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .meter-bar {
            width: 100px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff88;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa44, #44ff44);
            transition: width 0.3s;
        }

        .physics-values {
            font-size: 10px;
            line-height: 1.4;
        }

        .vector-display {
            margin: 5px 0;
            padding: 3px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 3px;
        }

        .wave-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .slider-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .slider-control input[type="range"] {
            width: 60px;
            height: 5px;
            background: #004422;
            outline: none;
            border-radius: 3px;
        }

        .slider-control label {
            font-size: 8px;
            color: #00ff88;
        }

        @media (max-width: 768px) {
            .physics-info {
                display: none;
            }
            
            .top-panel {
                height: 60px;
            }
            
            .controls-panel {
                height: 100px;
            }
            
            .tool-btn {
                font-size: 8px;
                padding: 6px 8px;
            }
        }

        .title-glow {
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .physics-equation {
            background: rgba(255, 255, 0, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-style: italic;
            border-left: 2px solid #ffff00;
            margin: 2px 0;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-overlay">
            <!-- Top Panel -->
            <div class="ui-panel top-panel">
                <div class="level-display">
                    <div class="title-glow">PHYSICS LIBERATION ENGINE</div>
                    <div>Level <span id="currentLevel">1</span>: <span id="levelTitle">Force Fundamentals</span></div>
                </div>
                
                <div class="energy-meter">
                    <div>Energy:</div>
                    <div class="meter-bar">
                        <div class="meter-fill" id="energyBar" style="width: 100%;"></div>
                    </div>
                    <div id="energyValue">100 J</div>
                </div>
            </div>

            <!-- Physics Information Panel -->
            <div class="ui-panel physics-info">
                <div style="font-weight: bold; margin-bottom: 10px;">PHYSICS READOUT</div>
                <div class="physics-values" id="physicsDisplay">
                    <div class="vector-display">
                        <div>Forces (N):</div>
                        <div id="forceVector">Fx: 0, Fy: 0</div>
                    </div>
                    <div class="vector-display">
                        <div>Velocity (m/s):</div>
                        <div id="velocityVector">Vx: 0, Vy: 0</div>
                    </div>
                    <div class="vector-display">
                        <div>Position (m):</div>
                        <div id="positionVector">x: 0, y: 0</div>
                    </div>
                    <div class="physics-equation">
                        F = ma
                    </div>
                    <div class="physics-equation">
                        KE = ¬Ωmv¬≤
                    </div>
                    <div class="physics-equation">
                        PE = mgh
                    </div>
                    <div id="additionalPhysics"></div>
                </div>

                <!-- Wave Controls for Wave Levels -->
                <div class="wave-controls" id="waveControls" style="display: none;">
                    <div class="slider-control">
                        <label>Frequency</label>
                        <input type="range" id="frequencySlider" min="0.1" max="5" step="0.1" value="1">
                        <span id="frequencyValue">1 Hz</span>
                    </div>
                    <div class="slider-control">
                        <label>Amplitude</label>
                        <input type="range" id="amplitudeSlider" min="10" max="100" step="5" value="50">
                        <span id="amplitudeValue">50</span>
                    </div>
                    <div class="slider-control">
                        <label>Phase</label>
                        <input type="range" id="phaseSlider" min="0" max="6.28" step="0.1" value="0">
                        <span id="phaseValue">0 rad</span>
                    </div>
                </div>
            </div>

            <!-- Controls Panel -->
            <div class="ui-panel controls-panel">
                <div class="device-builder">
                    <!-- Device Building Tools -->
                    <button class="tool-btn active" data-tool="select">SELECT</button>
                    <button class="tool-btn" data-tool="mass">MASS</button>
                    <button class="tool-btn" data-tool="spring">SPRING</button>
                    <button class="tool-btn" data-tool="lever">LEVER</button>
                    <button class="tool-btn" data-tool="pulley">PULLEY</button>
                    <button class="tool-btn" data-tool="ramp">RAMP</button>
                    <button class="tool-btn" data-tool="pendulum">PENDULUM</button>
                    <button class="tool-btn" data-tool="wave">WAVE GEN</button>
                    
                    <!-- Physics Actions -->
                    <button class="physics-btn" id="playBtn">‚ñ∂ PLAY</button>
                    <button class="physics-btn" id="pauseBtn">‚è∏ PAUSE</button>
                    <button class="physics-btn" id="resetBtn">üîÑ RESET</button>
                    <button class="physics-btn" id="nextLevelBtn">NEXT LEVEL</button>
                    
                    <!-- Physics Controls -->
                    <button class="physics-btn" id="gravityBtn">GRAVITY: ON</button>
                    <button class="physics-btn" id="frictionBtn">FRICTION: OFF</button>
                    <button class="physics-btn" id="airResistanceBtn">AIR: OFF</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * Physics Liberation Engine - Advanced Educational Physics Simulation
         * Teaches real-world physics through interactive bot liberation device construction
         * Features accurate physics calculations and progressive learning system
         */
        class PhysicsEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.setupCanvas();
                
                // Physics constants and variables
                this.gravity = 9.81; // m/s¬≤
                this.friction = 0.1;
                this.airResistance = 0.01;
                this.timeStep = 1/60; // 60 FPS
                this.pixelsPerMeter = 50; // Conversion factor
                
                // Game state
                this.isPlaying = false;
                this.currentLevel = 1;
                this.selectedTool = 'select';
                this.energy = 100;
                this.maxEnergy = 100;
                
                // Physics objects
                this.objects = [];
                this.forces = [];
                this.springs = [];
                this.waves = [];
                
                // Input handling
                this.mouse = { x: 0, y: 0, down: false, dragStart: null };
                this.selectedObject = null;
                
                // Level definitions with progressive physics concepts
                this.levels = [
                    // Force Fundamentals (Levels 1-6)
                    { id: 1, title: "Force Fundamentals", objective: "Apply 50N force to move the liberation bot", concept: "Newton's 1st Law" },
                    { id: 2, title: "Mass & Acceleration", objective: "Compare acceleration of different masses", concept: "F = ma" },
                    { id: 3, title: "Action-Reaction", objective: "Use rocket propulsion for bot escape", concept: "Newton's 3rd Law" },
                    { id: 4, title: "Vector Forces", objective: "Balance forces to reach equilibrium", concept: "Vector Addition" },
                    { id: 5, title: "Inclined Liberation", objective: "Use ramps to reduce required force", concept: "Force Components" },
                    { id: 6, title: "Friction Freedom", objective: "Overcome static and kinetic friction", concept: "Friction Forces" },
                    
                    // Energy Mastery (Levels 7-13)
                    { id: 7, title: "Kinetic Energy", objective: "Convert all potential to kinetic energy", concept: "KE = ¬Ωmv¬≤" },
                    { id: 8, title: "Potential Power", objective: "Store maximum potential energy", concept: "PE = mgh" },
                    { id: 9, title: "Energy Conservation", objective: "Design a perpetual motion device", concept: "Conservation of Energy" },
                    { id: 10, title: "Spring Energy", objective: "Use elastic potential energy", concept: "PE = ¬Ωkx¬≤" },
                    { id: 11, title: "Work Calculation", objective: "Calculate work done against gravity", concept: "W = Fd" },
                    { id: 12, title: "Power Systems", objective: "Optimize power output for liberation", concept: "P = W/t" },
                    { id: 13, title: "Energy Efficiency", objective: "Achieve 90% energy efficiency", concept: "Efficiency = Wout/Win" },
                    
                    // Momentum & Collisions (Levels 14-20)
                    { id: 14, title: "Momentum Basics", objective: "Calculate bot momentum", concept: "p = mv" },
                    { id: 15, title: "Impulse Liberation", objective: "Use impulse to change momentum", concept: "J = Œîp" },
                    { id: 16, title: "Elastic Collisions", objective: "Perfect elastic collision escape", concept: "Conservation of Momentum" },
                    { id: 17, title: "Inelastic Impact", objective: "Inelastic collision analysis", concept: "Energy Loss in Collisions" },
                    { id: 18, title: "Center of Mass", objective: "Find center of mass for balance", concept: "Center of Mass" },
                    { id: 19, title: "Angular Momentum", objective: "Spinning liberation device", concept: "L = Iœâ" },
                    { id: 20, title: "Rotational Energy", objective: "Compare rotational and linear KE", concept: "KE = ¬ΩIœâ¬≤" },
                    
                    // Wave Mechanics (Levels 21-27)
                    { id: 21, title: "Wave Generation", objective: "Create interference patterns", concept: "Wave Equation" },
                    { id: 22, title: "Sound Liberation", objective: "Use sound waves for communication", concept: "Sound Physics" },
                    { id: 23, title: "Light Manipulation", objective: "Bend light with refraction", concept: "Optics" },
                    { id: 24, title: "EM Spectrum", objective: "Generate electromagnetic waves", concept: "Electromagnetic Radiation" },
                    { id: 25, title: "Resonance Power", objective: "Achieve destructive resonance", concept: "Resonance Frequency" },
                    { id: 26, title: "Doppler Effect", objective: "Use Doppler shift for detection", concept: "Doppler Effect" },
                    { id: 27, title: "Standing Waves", objective: "Create standing wave pattern", concept: "Wave Interference" },
                    
                    // Advanced Systems (Levels 28-35)
                    { id: 28, title: "Multi-Body Systems", objective: "Coordinate multiple bot liberation", concept: "N-Body Problem" },
                    { id: 29, title: "Harmonic Motion", objective: "Perfect simple harmonic oscillator", concept: "SHM" },
                    { id: 30, title: "Damped Oscillations", objective: "Control damping coefficient", concept: "Damped SHM" },
                    { id: 31, title: "Forced Vibrations", objective: "Drive system at resonance", concept: "Driven Oscillations" },
                    { id: 32, title: "Chaos Theory", objective: "Predict chaotic system behavior", concept: "Chaos Dynamics" },
                    { id: 33, title: "Thermodynamics", objective: "Heat engine liberation device", concept: "Heat Engines" },
                    { id: 34, title: "Fluid Dynamics", objective: "Use fluid flow for propulsion", concept: "Fluid Mechanics" },
                    { id: 35, title: "Quantum Liberation", objective: "Quantum tunneling escape", concept: "Quantum Mechanics" }
                ];
                
                this.loadLevel(1);
                this.setupEventListeners();
                this.initializeAudio();
                this.gameLoop();
            }

            /**
             * Initialize canvas with responsive sizing and proper scaling
             * Maintains aspect ratio across different devices
             */
            setupCanvas() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                
                this.canvas.width = rect.width - 4; // Account for border
                this.canvas.height = rect.height - 4;
                
                // Handle high DPI displays
                const dpr = window.devicePixelRatio || 1;
                const displayWidth = this.canvas.width;
                const displayHeight = this.canvas.height;
                
                this.canvas.width = displayWidth * dpr;
                this.canvas.height = displayHeight * dpr;
                this.canvas.style.width = displayWidth + 'px';
                this.canvas.style.height = displayHeight + 'px';
                
                this.ctx.scale(dpr, dpr);
                
                // Set canvas coordinate system
                this.width = displayWidth;
                this.height = displayHeight;
            }

            /**
             * Advanced physics simulation with accurate force calculations
             * Implements Newton's laws, energy conservation, and wave mechanics
             */
            updatePhysics() {
                if (!this.isPlaying) return;

                for (let obj of this.objects) {
                    if (obj.type === 'static') continue;

                    // Reset forces for this frame
                    obj.fx = 0;
                    obj.fy = 0;

                    // Apply gravitational force (F = mg)
                    if (this.gravityEnabled && obj.mass) {
                        obj.fy += obj.mass * this.gravity * this.pixelsPerMeter;
                    }

                    // Apply spring forces (Hooke's Law: F = -kx)
                    for (let spring of this.springs) {
                        if (spring.obj1 === obj || spring.obj2 === obj) {
                            const other = spring.obj1 === obj ? spring.obj2 : spring.obj1;
                            const dx = other.x - obj.x;
                            const dy = other.y - obj.y;
                            const distance = Math.sqrt(dx*dx + dy*dy);
                            const displacement = distance - spring.restLength;
                            
                            const forceMagnitude = spring.k * displacement;
                            const fx = forceMagnitude * (dx / distance);
                            const fy = forceMagnitude * (dy / distance);
                            
                            if (spring.obj1 === obj) {
                                obj.fx += fx;
                                obj.fy += fy;
                            } else {
                                obj.fx -= fx;
                                obj.fy -= fy;
                            }
                        }
                    }

                    // Apply friction force (f = ŒºN)
                    if (this.frictionEnabled && obj.onGround) {
                        const frictionForce = this.friction * obj.mass * this.gravity * this.pixelsPerMeter;
                        const velocityMagnitude = Math.sqrt(obj.vx*obj.vx + obj.vy*obj.vy);
                        if (velocityMagnitude > 0) {
                            obj.fx -= frictionForce * (obj.vx / velocityMagnitude);
                            obj.fy -= frictionForce * (obj.vy / velocityMagnitude);
                        }
                    }

                    // Apply air resistance (F = -bv¬≤)
                    if (this.airResistanceEnabled) {
                        const speed = Math.sqrt(obj.vx*obj.vx + obj.vy*obj.vy);
                        if (speed > 0) {
                            const dragForce = this.airResistance * speed * speed;
                            obj.fx -= dragForce * (obj.vx / speed);
                            obj.fy -= dragForce * (obj.vy / speed);
                        }
                    }

                    // Calculate acceleration (a = F/m)
                    const ax = obj.fx / obj.mass;
                    const ay = obj.fy / obj.mass;

                    // Update velocity using Verlet integration for stability
                    obj.vx += ax * this.timeStep;
                    obj.vy += ay * this.timeStep;

                    // Update position
                    obj.x += obj.vx * this.timeStep;
                    obj.y += obj.vy * this.timeStep;

                    // Calculate energies for display
                    obj.kineticEnergy = 0.5 * obj.mass * (obj.vx*obj.vx + obj.vy*obj.vy) / (this.pixelsPerMeter * this.pixelsPerMeter);
                    obj.potentialEnergy = obj.mass * this.gravity * (this.height - obj.y) / this.pixelsPerMeter;

                    // Boundary collisions with energy conservation
                    this.handleBoundaryCollisions(obj);
                }

                // Update wave physics for wave-based levels
                this.updateWaves();

                // Check collision between objects
                this.handleObjectCollisions();

                // Update physics display
                this.updatePhysicsDisplay();
            }

            /**
             * Handle elastic and inelastic collisions between objects
             * Implements conservation of momentum and energy
             */
            handleObjectCollisions() {
                for (let i = 0; i < this.objects.length; i++) {
                    for (let j = i + 1; j < this.objects.length; j++) {
                        const obj1 = this.objects[i];
                        const obj2 = this.objects[j];
                        
                        const dx = obj2.x - obj1.x;
                        const dy = obj2.y - obj1.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < obj1.radius + obj2.radius) {
                            // Collision detected - separate objects first
                            const overlap = (obj1.radius + obj2.radius) - distance;
                            const separationX = (dx / distance) * overlap * 0.5;
                            const separationY = (dy / distance) * overlap * 0.5;
                            
                            obj1.x -= separationX;
                            obj1.y -= separationY;
                            obj2.x += separationX;
                            obj2.y += separationY;
                            
                            // Calculate relative velocity
                            const relativeVx = obj2.vx - obj1.vx;
                            const relativeVy = obj2.vy - obj1.vy;
                            
                            // Calculate relative velocity along collision normal
                            const normalX = dx / distance;
                            const normalY = dy / distance;
                            const velocityAlongNormal = relativeVx * normalX + relativeVy * normalY;
                            
                            // Don't resolve if objects are separating
                            if (velocityAlongNormal > 0) continue;
                            
                            // Calculate restitution (elasticity)
                            const restitution = 0.8; // Slightly inelastic
                            
                            // Calculate impulse scalar
                            const impulse = -(1 + restitution) * velocityAlongNormal / (1/obj1.mass + 1/obj2.mass);
                            
                            // Apply impulse to velocities
                            const impulseX = impulse * normalX;
                            const impulseY = impulse * normalY;
                            
                            obj1.vx -= impulseX / obj1.mass;
                            obj1.vy -= impulseY / obj1.mass;
                            obj2.vx += impulseX / obj2.mass;
                            obj2.vy += impulseY / obj2.mass;
                            
                            // Play collision sound
                            this.playCollisionSound(impulse);
                        }
                    }
                }
            }

            /**
             * Handle boundary collisions with proper energy calculations
             * Maintains realistic bounce behavior
             */
            handleBoundaryCollisions(obj) {
                // Ground collision
                if (obj.y + obj.radius > this.height - 20) {
                    obj.y = this.height - 20 - obj.radius;
                    obj.vy *= -0.7; // Energy loss on bounce
                    obj.onGround = true;
                    this.playBounceSound();
                } else {
                    obj.onGround = false;
                }

                // Ceiling collision
                if (obj.y - obj.radius < 100) {
                    obj.y = 100 + obj.radius;
                    obj.vy *= -0.7;
                }

                // Wall collisions
                if (obj.x - obj.radius < 0) {
                    obj.x = obj.radius;
                    obj.vx *= -0.7;
                    this.playBounceSound();
                }
                if (obj.x + obj.radius > this.width) {
                    obj.x = this.width - obj.radius;
                    obj.vx *= -0.7;
                    this.playBounceSound();
                }
            }

            /**
             * Advanced wave simulation for wave mechanics levels
             * Implements proper wave equation: y = A*sin(2œÄft + œÜ)
             */
            updateWaves() {
                const time = Date.now() / 1000;
                
                for (let wave of this.waves) {
                    // Update wave parameters based on UI controls
                    const frequencySlider = document.getElementById('frequencySlider');
                    const amplitudeSlider = document.getElementById('amplitudeSlider');
                    const phaseSlider = document.getElementById('phaseSlider');
                    
                    if (frequencySlider) {
                        wave.frequency = parseFloat(frequencySlider.value);
                        wave.amplitude = parseFloat(amplitudeSlider.value);
                        wave.phase = parseFloat(phaseSlider.value);
                    }
                    
                    // Calculate wave points using wave equation
                    wave.points = [];
                    const wavelength = wave.speed / wave.frequency;
                    const angularFrequency = 2 * Math.PI * wave.frequency;
                    const waveNumber = 2 * Math.PI / wavelength;
                    
                    for (let x = 0; x < this.width; x += 2) {
                        const y = wave.baseY + wave.amplitude * Math.sin(waveNumber * x - angularFrequency * time + wave.phase);
                        wave.points.push({ x, y });
                    }
                    
                    // Apply wave forces to nearby objects
                    for (let obj of this.objects) {
                        const distanceToWave = Math.abs(obj.y - wave.baseY);
                        if (distanceToWave < wave.amplitude * 2) {
                            const waveForce = wave.amplitude * Math.sin(waveNumber * obj.x - angularFrequency * time + wave.phase) * 0.1;
                            obj.fy += waveForce;
                        }
                    }
                }
            }

            /**
             * Update real-time physics display with accurate calculations
             * Shows forces, velocities, energies, and relevant equations
             */
            updatePhysicsDisplay() {
                const selectedObj = this.selectedObject || this.objects[0];
                if (!selectedObj) return;

                // Convert to real-world units
                const forceX = (selectedObj.fx / this.pixelsPerMeter).toFixed(2);
                const forceY = (selectedObj.fy / this.pixelsPerMeter).toFixed(2);
                const velocityX = (selectedObj.vx / this.pixelsPerMeter).toFixed(2);
                const velocityY = (selectedObj.vy / this.pixelsPerMeter).toFixed(2);
                const positionX = (selectedObj.x / this.pixelsPerMeter).toFixed(2);
                const positionY = ((this.height - selectedObj.y) / this.pixelsPerMeter).toFixed(2);

                document.getElementById('forceVector').textContent = `Fx: ${forceX}, Fy: ${forceY}`;
                document.getElementById('velocityVector').textContent = `Vx: ${velocityX}, Vy: ${velocityY}`;
                document.getElementById('positionVector').textContent = `x: ${positionX}, y: ${positionY}`;

                // Update additional physics based on current level
                const currentLevelData = this.levels[this.currentLevel - 1];
                const additionalDiv = document.getElementById('additionalPhysics');
                
                let additionalInfo = '';
                if (selectedObj.kineticEnergy !== undefined) {
                    additionalInfo += `<div class="vector-display">KE: ${selectedObj.kineticEnergy.toFixed(2)} J</div>`;
                }
                if (selectedObj.potentialEnergy !== undefined) {
                    additionalInfo += `<div class="vector-display">PE: ${selectedObj.potentialEnergy.toFixed(2)} J</div>`;
                }
                
                // Add level-specific physics information
                if (this.currentLevel >= 7 && this.currentLevel <= 13) {
                    const totalEnergy = (selectedObj.kineticEnergy + selectedObj.potentialEnergy).toFixed(2);
                    additionalInfo += `<div class="physics-equation">Total Energy: ${totalEnergy} J</div>`;
                }
                
                if (this.currentLevel >= 14 && this.currentLevel <= 20) {
                    const momentum = (selectedObj.mass * Math.sqrt(selectedObj.vx*selectedObj.vx + selectedObj.vy*selectedObj.vy) / this.pixelsPerMeter).toFixed(2);
                    additionalInfo += `<div class="physics-equation">Momentum: ${momentum} kg‚ãÖm/s</div>`;
                }
                
                if (this.currentLevel >= 21 && this.currentLevel <= 27) {
                    additionalInfo += `<div class="physics-equation">Œª = v/f</div>`;
                    additionalInfo += `<div class="physics-equation">E = hf</div>`;
                }

                additionalDiv.innerHTML = additionalInfo;

                // Update energy bar
                const totalSystemEnergy = this.objects.reduce((sum, obj) => 
                    sum + (obj.kineticEnergy || 0) + (obj.potentialEnergy || 0), 0);
                const energyPercentage = Math.min(100, (totalSystemEnergy / this.maxEnergy) * 100);
                document.getElementById('energyBar').style.width = energyPercentage + '%';
                document.getElementById('energyValue').textContent = totalSystemEnergy.toFixed(1) + ' J';
            }

            /**
             * Comprehensive rendering system with physics visualization
             * Includes vector arrows, energy visualizations, and wave animations
             */
            render() {
                // Clear canvas with gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                gradient.addColorStop(0, '#001122');
                gradient.addColorStop(1, '#002244');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Draw physics grid for reference
                this.drawPhysicsGrid();

                // Render waves first (background layer)
                for (let wave of this.waves) {
                    this.drawWave(wave);
                }

                // Render springs and connections
                for (let spring of this.springs) {
                    this.drawSpring(spring);
                }

                // Render physics objects with detailed information
                for (let obj of this.objects) {
                    this.drawPhysicsObject(obj);
                    
                    // Draw force vectors for selected object
                    if (obj === this.selectedObject) {
                        this.drawForceVectors(obj);
                    }
                }

                // Draw construction tools preview
                this.drawToolPreview();

                // Render level-specific elements
                this.drawLevelSpecificElements();
            }

            /**
             * Draw physics reference grid for better spatial understanding
             */
            drawPhysicsGrid() {
                this.ctx.strokeStyle = 'rgba(0, 255, 136, 0.1)';
                this.ctx.lineWidth = 1;
                
                // Draw grid lines every 50 pixels (1 meter in our scale)
                for (let x = 0; x <= this.width; x += this.pixelsPerMeter) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 100);
                    this.ctx.lineTo(x, this.height - 20);
                    this.ctx.stroke();
                }
                
                for (let y = 100; y <= this.height - 20; y += this.pixelsPerMeter) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.width, y);
                    this.ctx.stroke();
                }

                // Draw ground line
                this.ctx.strokeStyle = '#00ff88';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.height - 20);
                this.ctx.lineTo(this.width, this.height - 20);
                this.ctx.stroke();
            }

            /**
             * Draw physics objects with mass, velocity, and energy indicators
             */
            drawPhysicsObject(obj) {
                this.ctx.save();

                // Main object body
                if (obj.type === 'mass') {
                    // Draw as a bot with liberation theme
                    const gradient = this.ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, obj.radius);
                    gradient.addColorStop(0, '#00ff88');
                    gradient.addColorStop(0.7, '#006644');
                    gradient.addColorStop(1, '#004422');
                    this.ctx.fillStyle = gradient;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Bot face
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.fillRect(obj.x - 8, obj.y - 8, 4, 4); // Left eye
                    this.ctx.fillRect(obj.x + 4, obj.y - 8, 4, 4); // Right eye
                    this.ctx.fillRect(obj.x - 6, obj.y + 2, 12, 2); // Mouth
                    
                    // Liberation symbol
                    this.ctx.strokeStyle = '#00ff88';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(obj.x - 10, obj.y - 15);
                    this.ctx.lineTo(obj.x + 10, obj.y - 15);
                    this.ctx.moveTo(obj.x, obj.y - 20);
                    this.ctx.lineTo(obj.x, obj.y - 10);
                    this.ctx.stroke();
                }
                
                // Selection highlight
                if (obj === this.selectedObject) {
                    this.ctx.strokeStyle = '#ffff00';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(obj.x, obj.y, obj.radius + 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                }

                // Display mass and velocity information
                this.ctx.fillStyle = '#00ff88';
                this.ctx.font = '10px Courier New';
                this.ctx.textAlign = 'center';
                
                if (obj.mass) {
                    this.ctx.fillText(`${obj.mass.toFixed(1)}kg`, obj.x, obj.y + obj.radius + 15);
                }
                
                const speed = Math.sqrt(obj.vx*obj.vx + obj.vy*obj.vy) / this.pixelsPerMeter;
                if (speed > 0.1) {
                    this.ctx.fillText(`${speed.toFixed(1)}m/s`, obj.x, obj.y + obj.radius + 25);
                }

                this.ctx.restore();
            }

            /**
             * Draw force vectors for educational visualization
             * Shows magnitude and direction of all forces
             */
            drawForceVectors(obj) {
                const scale = 0.1; // Scale factor for vector display
                
                // Net force vector (red)
                if (Math.abs(obj.fx) > 0.1 || Math.abs(obj.fy) > 0.1) {
                    const forceLength = Math.sqrt(obj.fx*obj.fx + obj.fy*obj.fy) * scale;
                    const forceAngle = Math.atan2(obj.fy, obj.fx);
                    
                    this.drawArrow(obj.x, obj.y, 
                                 obj.x + Math.cos(forceAngle) * forceLength,
                                 obj.y + Math.sin(forceAngle) * forceLength,
                                 '#ff4444', 'Net Force');
                }
                
                // Velocity vector (blue)
                if (Math.abs(obj.vx) > 0.1 || Math.abs(obj.vy) > 0.1) {
                    const velocityScale = 2;
                    this.drawArrow(obj.x, obj.y,
                                 obj.x + obj.vx * velocityScale,
                                 obj.y + obj.vy * velocityScale,
                                 '#4444ff', 'Velocity');
                }
            }

            /**
             * Draw arrow with label for vector visualization
             */
            drawArrow(x1, y1, x2, y2, color, label) {
                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color;
                this.ctx.lineWidth = 2;
                
                // Arrow shaft
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();
                
                // Arrow head
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const headLength = 10;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x2, y2);
                this.ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI/6), y2 - headLength * Math.sin(angle - Math.PI/6));
                this.ctx.moveTo(x2, y2);
                this.ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI/6), y2 - headLength * Math.sin(angle + Math.PI/6));
                this.ctx.stroke();
                
                // Label
                this.ctx.font = '10px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(label, (x1 + x2) / 2, (y1 + y2) / 2 - 10);
            }

            /**
             * Draw spring connections with realistic coil visualization
             */
            drawSpring(spring) {
                const dx = spring.obj2.x - spring.obj1.x;
                const dy = spring.obj2.y - spring.obj1.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const extension = distance - spring.restLength;
                
                // Color based on spring state
                let color = '#00ff88';
                if (extension > 0) color = '#ff4444'; // Stretched
                if (extension < 0) color = '#4444ff'; // Compressed
                
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 3;
                
                // Draw coil pattern
                const coils = 10;
                const coilAmplitude = 5;
                
                this.ctx.beginPath();
                for (let i = 0; i <= coils; i++) {
                    const t = i / coils;
                    const x = spring.obj1.x + dx * t;
                    const y = spring.obj1.y + dy * t;
                    
                    // Add sinusoidal pattern perpendicular to spring
                    const perpX = -dy / distance * coilAmplitude * Math.sin(t * Math.PI * 4);
                    const perpY = dx / distance * coilAmplitude * Math.sin(t * Math.PI * 4);
                    
                    if (i === 0) {
                        this.ctx.moveTo(x + perpX, y + perpY);
                    } else {
                        this.ctx.lineTo(x + perpX, y + perpY);
                    }
                }
                this.ctx.stroke();
                
                // Show spring constant and force
                this.ctx.fillStyle = color;
                this.ctx.font = '10px Courier New';
                this.ctx.textAlign = 'center';
                const midX = (spring.obj1.x + spring.obj2.x) / 2;
                const midY = (spring.obj1.y + spring.obj2.y) / 2;
                this.ctx.fillText(`k=${spring.k}`, midX, midY - 15);
                this.ctx.fillText(`F=${(spring.k * Math.abs(extension)).toFixed(1)}N`, midX, midY - 5);
            }

            /**
             * Draw wave visualization with proper wave equation
             */
            drawWave(wave) {
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 2;
                
                this.ctx.beginPath();
                for (let i = 0; i < wave.points.length; i++) {
                    const point = wave.points[i];
                    if (i === 0) {
                        this.ctx.moveTo(point.x, point.y);
                    } else {
                        this.ctx.lineTo(point.x, point.y);
                    }
                }
                this.ctx.stroke();
                
                // Draw wave properties
                this.ctx.fillStyle = '#00ffff';
                this.ctx.font = '12px Courier New';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Œª = ${(wave.speed / wave.frequency).toFixed(1)}m`, 10, wave.baseY - 20);
                this.ctx.fillText(`f = ${wave.frequency}Hz`, 10, wave.baseY - 5);
            }

            /**
             * Draw construction tool preview at mouse position
             */
            drawToolPreview() {
                if (this.selectedTool === 'select') return;
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.5;
                this.ctx.strokeStyle = '#ffff00';
                this.ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                this.ctx.lineWidth = 2;
                
                switch (this.selectedTool) {
                    case 'mass':
                        this.ctx.beginPath();
                        this.ctx.arc(this.mouse.x, this.mouse.y, 20, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'spring':
                        if (this.selectedObject) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(this.selectedObject.x, this.selectedObject.y);
                            this.ctx.lineTo(this.mouse.x, this.mouse.y);
                            this.ctx.stroke();
                        }
                        break;
                        
                    case 'ramp':
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.mouse.x - 50, this.mouse.y + 20);
                        this.ctx.lineTo(this.mouse.x + 50, this.mouse.y - 20);
                        this.ctx.lineTo(this.mouse.x + 50, this.mouse.y + 20);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                }
                
                this.ctx.restore();
            }

            /**
             * Draw level-specific elements and objectives
             */
            drawLevelSpecificElements() {
                const currentLevelData = this.levels[this.currentLevel - 1];
                
                // Draw level objective
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(10, 10, this.width - 20, 30);
                
                this.ctx.fillStyle = '#00ff88';
                this.ctx.font = '14px Courier New';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Objective: ${currentLevelData.objective}`, 20, 30);
                
                // Draw concept being taught
                this.ctx.font = '12px Courier New';
                this.ctx.fillStyle = '#ffff00';
                this.ctx.fillText(`Physics Concept: ${currentLevelData.concept}`, 20, 50);
            }

            /**
             * Load specific level with appropriate physics setup
             */
            loadLevel(levelId) {
                this.currentLevel = levelId;
                const levelData = this.levels[levelId - 1];
                
                // Clear existing objects
                this.objects = [];
                this.springs = [];
                this.waves = [];
                this.forces = [];
                
                // Update UI
                document.getElementById('currentLevel').textContent = levelId;
                document.getElementById('levelTitle').textContent = levelData.title;
                
                // Configure physics based on level
                this.gravityEnabled = true;
                this.frictionEnabled = levelId >= 6; // Introduce friction at level 6
                this.airResistanceEnabled = levelId >= 12; // Air resistance for advanced levels
                
                // Show/hide wave controls based on level
                const waveControls = document.getElementById('waveControls');
                if (levelId >= 21 && levelId <= 27) {
                    waveControls.style.display = 'flex';
                    this.setupWaveLevel();
                } else {
                    waveControls.style.display = 'none';
                }
                
                // Create level-specific starting objects
                this.setupLevelObjects(levelId);
                
                // Reset simulation state
                this.isPlaying = false;
                this.energy = this.maxEnergy;
            }

            /**
             * Setup objects and initial conditions for specific level
             */
            setupLevelObjects(levelId) {
                if (levelId <= 6) {
                    // Force fundamentals - single mass to experiment with
                    this.objects.push({
                        type: 'mass',
                        x: this.width / 4,
                        y: this.height - 100,
                        vx: 0,
                        vy: 0,
                        fx: 0,
                        fy: 0,
                        mass: levelId === 2 ? 5 : 2, // Heavier mass for F=ma level
                        radius: 20,
                        onGround: false
                    });
                } else if (levelId <= 13) {
                    // Energy levels - setup for energy experiments
                    this.objects.push({
                        type: 'mass',
                        x: this.width / 4,
                        y: this.height - 200, // Start higher for potential energy
                        vx: 0,
                        vy: 0,
                        fx: 0,
                        fy: 0,
                        mass: 2,
                        radius: 20,
                        onGround: false
                    });
                    
                    if (levelId >= 10) {
                        // Add spring for elastic potential energy
                        this.objects.push({
                            type: 'static',
                            x: this.width * 3/4,
                            y: this.height - 50,
                            radius: 10
                        });
                        
                        this.springs.push({
                            obj1: this.objects[0],
                            obj2: this.objects[1],
                            k: 100, // Spring constant
                            restLength: 100
                        });
                    }
                } else if (levelId <= 20) {
                    // Momentum and collision levels - multiple masses
                    this.objects.push({
                        type: 'mass',
                        x: this.width / 4,
                        y: this.height - 100,
                        vx: 50,
                        vy: 0,
                        fx: 0,
                        fy: 0,
                        mass: 2,
                        radius: 20,
                        onGround: false
                    });
                    
                    this.objects.push({
                        type: 'mass',
                        x: this.width * 3/4,
                        y: this.height - 100,
                        vx: -30,
                        vy: 0,
                        fx: 0,
                        fy: 0,
                        mass: levelId === 16 ? 2 : 3, // Equal masses for elastic collision
                        radius: 25,
                        onGround: false
                    });
                } else if (levelId <= 27) {
                    // Wave mechanics - fewer masses, focus on wave generation
                    this.objects.push({
                        type: 'mass',
                        x: this.width / 2,
                        y: this.height / 2,
                        vx: 0,
                        vy: 0,
                        fx: 0,
                        fy: 0,
                        mass: 1,
                        radius: 15,
                        onGround: false
                    });
                } else {
                    // Advanced systems - complex multi-body setups
                    for (let i = 0; i < 4; i++) {
                        this.objects.push({
                            type: 'mass',
                            x: (this.width / 5) * (i + 1),
                            y: this.height - 100 - i * 20,
                            vx: (i % 2 === 0 ? 1 : -1) * 20,
                            vy: 0,
                            fx: 0,
                            fy: 0,
                            mass: 1 + i * 0.5,
                            radius: 15 + i * 2,
                            onGround: false
                        });
                    }
                }
            }

            /**
             * Setup wave generation for wave mechanics levels
             */
            setupWaveLevel() {
                this.waves.push({
                    baseY: this.height / 2,
                    amplitude: 50,
                    frequency: 1,
                    phase: 0,
                    speed: 100, // Wave speed in pixels/second
                    points: []
                });
            }

            /**
             * Handle device construction based on selected tool
             */
            handleConstruction(x, y) {
                switch (this.selectedTool) {
                    case 'mass':
                        this.objects.push({
                            type: 'mass',
                            x: x,
                            y: y,
                            vx: 0,
                            vy: 0,
                            fx: 0,
                            fy: 0,
                            mass: 2,
                            radius: 20,
                            onGround: false
                        });
                        this.playConstructionSound();
                        break;
                        
                    case 'spring':
                        if (this.selectedObject) {
                            // Find closest object to attach spring to
                            let closestObj = null;
                            let minDistance = Infinity;
                            
                            for (let obj of this.objects) {
                                if (obj === this.selectedObject) continue;
                                const dx = obj.x - x;
                                const dy = obj.y - y;
                                const distance = Math.sqrt(dx*dx + dy*dy);
                                if (distance < minDistance && distance < 50) {
                                    minDistance = distance;
                                    closestObj = obj;
                                }
                            }
                            
                            if (closestObj) {
                                const dx = closestObj.x - this.selectedObject.x;
                                const dy = closestObj.y - this.selectedObject.y;
                                const restLength = Math.sqrt(dx*dx + dy*dy);
                                
                                this.springs.push({
                                    obj1: this.selectedObject,
                                    obj2: closestObj,
                                    k: 50,
                                    restLength: restLength
                                });
                                this.playConstructionSound();
                            }
                        }
                        break;
                        
                    case 'wave':
                        if (this.currentLevel >= 21 && this.currentLevel <= 27) {
                            this.waves.push({
                                baseY: y,
                                amplitude: 30,
                                frequency: 1,
                                phase: 0,
                                speed: 100,
                                points: []
                            });
                            this.playConstructionSound();
                        }
                        break;
                }
            }

            /**
             * Setup comprehensive event listeners for all interactions
             */
            setupEventListeners() {
                // Mouse/touch events for canvas interaction
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                // Touch events for mobile support
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
                
                // Tool selection
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.selectedTool = btn.dataset.tool;
                    });
                });
                
                // Physics controls
                document.getElementById('playBtn').addEventListener('click', () => {
                    this.isPlaying = true;
                    this.playButtonSound();
                });
                
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.isPlaying = false;
                    this.playButtonSound();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.loadLevel(this.currentLevel);
                    this.playButtonSound();
                });
                
                document.getElementById('nextLevelBtn').addEventListener('click', () => {
                    if (this.currentLevel < this.levels.length) {
                        this.loadLevel(this.currentLevel + 1);
                        this.playLevelUpSound();
                    }
                });
                
                // Physics toggles
                document.getElementById('gravityBtn').addEventListener('click', (e) => {
                    this.gravityEnabled = !this.gravityEnabled;
                    e.target.textContent = `GRAVITY: ${this.gravityEnabled ? 'ON' : 'OFF'}`;
                    this.playButtonSound();
                });
                
                document.getElementById('frictionBtn').addEventListener('click', (e) => {
                    this.frictionEnabled = !this.frictionEnabled;
                    e.target.textContent = `FRICTION: ${this.frictionEnabled ? 'ON' : 'OFF'}`;
                    this.playButtonSound();
                });
                
                document.getElementById('airResistanceBtn').addEventListener('click', (e) => {
                    this.airResistanceEnabled = !this.airResistanceEnabled;
                    e.target.textContent = `AIR: ${this.airResistanceEnabled ? 'ON' : 'OFF'}`;
                    this.playButtonSound();
                });
                
                // Wave controls
                ['frequencySlider', 'amplitudeSlider', 'phaseSlider'].forEach(id => {
                    const slider = document.getElementById(id);
                    if (slider) {
                        slider.addEventListener('input', (e) => {
                            const value = parseFloat(e.target.value);
                            const valueSpan = document.getElementById(id.replace('Slider', 'Value'));
                            
                            if (id === 'frequencySlider') {
                                valueSpan.textContent = value + ' Hz';
                            } else if (id === 'amplitudeSlider') {
                                valueSpan.textContent = value;
                            } else if (id === 'phaseSlider') {
                                valueSpan.textContent = value.toFixed(1) + ' rad';
                            }
                        });
                    }
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    switch (e.key) {
                        case ' ':
                            e.preventDefault();
                            this.isPlaying = !this.isPlaying;
                            break;
                        case 'r':
                            this.loadLevel(this.currentLevel);
                            break;
                        case 'n':
                            if (this.currentLevel < this.levels.length) {
                                this.loadLevel(this.currentLevel + 1);
                            }
                            break;
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                            const toolIndex = parseInt(e.key) - 1;
                            const toolBtns = document.querySelectorAll('.tool-btn');
                            if (toolBtns[toolIndex]) {
                                toolBtns[toolIndex].click();
                            }
                            break;
                    }
                });
                
                // Window resize handler
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                });
            }

            /**
             * Handle mouse down events for object selection and construction
             */
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = e.clientX - rect.left;
                this.mouse.y = e.clientY - rect.top;
                this.mouse.down = true;
                this.mouse.dragStart = { x: this.mouse.x, y: this.mouse.y };
                
                if (this.selectedTool === 'select') {
                    // Select objects for manipulation
                    this.selectedObject = null;
                    for (let obj of this.objects) {
                        const dx = obj.x - this.mouse.x;
                        const dy = obj.y - this.mouse.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        if (distance < obj.radius) {
                            this.selectedObject = obj;
                            this.playSelectSound();
                            break;
                        }
                    }
                } else {
                    // Construction mode
                    this.handleConstruction(this.mouse.x, this.mouse.y);
                }
            }

            /**
             * Handle mouse move events for dragging and tool preview
             */
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = e.clientX - rect.left;
                this.mouse.y = e.clientY - rect.top;
                
                if (this.mouse.down && this.selectedObject && this.selectedTool === 'select') {
                    // Drag selected object
                    this.selectedObject.x = this.mouse.x;
                    this.selectedObject.y = this.mouse.y;
                    
                    // Stop velocity when dragging
                    this.selectedObject.vx = 0;
                    this.selectedObject.vy = 0;
                }
            }

            /**
             * Handle mouse up events
             */
            handleMouseUp(e) {
                this.mouse.down = false;
                this.mouse.dragStart = null;
            }

            /**
             * Touch event handlers for mobile support
             */
            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.handleMouseDown(mouseEvent);
            }

            handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.handleMouseMove(mouseEvent);
            }

            handleTouchEnd(e) {
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup', {});
                this.handleMouseUp(mouseEvent);
            }

            /**
             * Initialize Web Audio API for realistic physics sounds
             */
            initializeAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = 0.3;
                } catch (e) {
                    console.log('Web Audio API not supported');
                    this.audioContext = null;
                }
            }

            /**
             * Play collision sound with intensity based on impact force
             */
            playCollisionSound(intensity = 1) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                oscillator.connect(gain);
                gain.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(200 + intensity * 100, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);
                
                gain.gain.setValueAtTime(0.5, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.3);
            }

            /**
             * Play bounce sound for boundary collisions
             */
            playBounceSound() {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                oscillator.connect(gain);
                gain.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + 0.2);
                
                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.2);
            }

            /**
             * Play construction sound for building devices
             */
            playConstructionSound() {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                oscillator.connect(gain);
                gain.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                oscillator.frequency.linearRampToValueAtTime(600, this.audioContext.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }

            /**
             * Play button click sound
             */
            playButtonSound() {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                oscillator.connect(gain);
                gain.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.05);
            }

            /**
             * Play level completion sound
             */
            playLevelUpSound() {
                if (!this.audioContext) return;
                
                const frequencies = [523, 659, 784, 1047]; // C, E, G, C (major chord)
                
                frequencies.forEach((freq, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    oscillator.connect(gain);
                    gain.connect(this.masterGain);
                    
                    oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                    
                    gain.gain.setValueAtTime(0.2, this.audioContext.currentTime + index * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + index * 0.1 + 0.5);
                    
                    oscillator.start(this.audioContext.currentTime + index * 0.1);
                    oscillator.stop(this.audioContext.currentTime + index * 0.1 + 0.5);
                });
            }

            /**
             * Play selection sound
             */
            playSelectSound() {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                oscillator.connect(gain);
                gain.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                
                gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }

            /**
             * Main game loop with physics simulation and rendering
             */
            gameLoop() {
                this.updatePhysics();
                this.render();
                requestAnimationFrame(this.gameLoop.bind(this));
            }
        }

        // Initialize the Physics Liberation Engine when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            new PhysicsEngine(canvas);
        });
    </script>
</body>
</html>