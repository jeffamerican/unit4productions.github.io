<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logic Circuit Builder - BotInc Games</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Arial', sans-serif;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            max-width: 1000px;
            width: 95%;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 107, 53, 0.3);
        }

        .game-info {
            margin-bottom: 30px;
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .game-area {
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            gap: 20px;
            margin: 20px 0;
        }

        .component-palette {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 107, 53, 0.3);
        }

        .palette-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ff6b35;
        }

        .component-item {
            background: rgba(255, 107, 53, 0.2);
            padding: 10px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            font-size: 0.9rem;
        }

        .component-item:hover {
            background: rgba(255, 107, 53, 0.4);
            border-color: #ff6b35;
            transform: translateX(5px);
        }

        .component-item.selected {
            border-color: #f7931e;
            background: rgba(247, 147, 30, 0.3);
        }

        #circuitCanvas {
            border: 2px solid #ff6b35;
            border-radius: 10px;
            background: #111;
            cursor: crosshair;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.3);
        }

        .test-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 107, 53, 0.3);
        }

        .test-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ff6b35;
        }

        .input-control {
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 107, 53, 0.1);
            border-radius: 5px;
        }

        .input-label {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-left: 10px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #ff6b35;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .output-display {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            border: none;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-box {
            background: rgba(255, 107, 53, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 53, 0.3);
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #ff6b35;
        }

        .game-log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 107, 53, 0.3);
        }

        .log-entry {
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .home-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .home-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .instructions {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 0.95rem;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }
            
            .game-container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            #circuitCanvas {
                width: 100%;
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="home-button">‚Üê Back to Games</a>

    <div class="game-container">
        <h1>Logic Circuit Builder</h1>
        <div class="game-info">Design and simulate digital logic circuits with gates, inputs, and outputs</div>

        <div class="instructions">
            <strong>How to Play:</strong> Select components from the palette and click on the canvas to place them. 
            Click and drag to create connections between components. Use the test panel to set input values and observe outputs.
        </div>

        <div class="game-area">
            <div class="component-palette">
                <div class="palette-title">Components</div>
                <div class="component-item" data-type="input">üì• Input</div>
                <div class="component-item" data-type="output">üì§ Output</div>
                <div class="component-item" data-type="and">AND Gate</div>
                <div class="component-item" data-type="or">OR Gate</div>
                <div class="component-item" data-type="not">NOT Gate</div>
                <div class="component-item" data-type="nand">NAND Gate</div>
                <div class="component-item" data-type="nor">NOR Gate</div>
                <div class="component-item" data-type="xor">XOR Gate</div>
                <div class="component-item" data-type="wire">üîó Wire</div>
            </div>

            <canvas id="circuitCanvas" width="500" height="400"></canvas>

            <div class="test-panel">
                <div class="test-title">Test Controls</div>
                <div id="inputControls"></div>
                <div class="test-title" style="margin-top: 20px;">Outputs</div>
                <div id="outputDisplay" class="output-display">No outputs connected</div>
                <button onclick="game.simulate()">Simulate Circuit</button>
            </div>
        </div>

        <div class="controls">
            <button onclick="game.clearCanvas()">Clear Circuit</button>
            <button onclick="game.saveCircuit()">Save Design</button>
            <button onclick="game.loadExample()">Load Example</button>
            <button onclick="game.validateCircuit()">Validate Circuit</button>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Components</div>
                <div class="stat-value" id="componentCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Connections</div>
                <div class="stat-value" id="connectionCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Inputs</div>
                <div class="stat-value" id="inputCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Outputs</div>
                <div class="stat-value" id="outputCount">0</div>
            </div>
        </div>

        <div class="game-log" id="gameLog">
            <div class="log-entry">üîß Logic Circuit Builder initialized. Start building your circuit!</div>
        </div>
    </div>

    <script>
        class LogicCircuitBuilder {
            constructor() {
                this.canvas = document.getElementById('circuitCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.selectedTool = null;
                this.components = [];
                this.connections = [];
                this.isConnecting = false;
                this.connectionStart = null;
                this.nextId = 1;
                
                this.setupEventListeners();
                this.updateStats();
                this.logAction("üéÆ Circuit builder ready for construction!");
            }

            setupEventListeners() {
                // Component palette selection
                document.querySelectorAll('.component-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        document.querySelectorAll('.component-item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                        this.selectedTool = item.dataset.type;
                        this.isConnecting = false;
                        this.connectionStart = null;
                        this.logAction(`üîß Selected tool: ${item.textContent.trim()}`);
                    });
                });

                // Canvas interactions
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasMove(e));
                
                this.render();
            }

            handleCanvasClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (this.selectedTool === 'wire') {
                    this.handleWireMode(x, y);
                } else if (this.selectedTool) {
                    this.placeComponent(x, y);
                } else {
                    // Select existing component
                    const component = this.getComponentAt(x, y);
                    if (component) {
                        this.logAction(`üéØ Selected ${component.type} component`);
                    }
                }
            }

            handleWireMode(x, y) {
                const component = this.getComponentAt(x, y);
                
                if (!this.isConnecting) {
                    if (component) {
                        this.isConnecting = true;
                        this.connectionStart = component;
                        this.logAction(`üîó Starting connection from ${component.type}`);
                    }
                } else {
                    if (component && component !== this.connectionStart) {
                        this.createConnection(this.connectionStart, component);
                        this.isConnecting = false;
                        this.connectionStart = null;
                    } else {
                        this.isConnecting = false;
                        this.connectionStart = null;
                        this.logAction("‚ùå Connection cancelled");
                    }
                }
            }

            placeComponent(x, y) {
                const component = {
                    id: this.nextId++,
                    type: this.selectedTool,
                    x: x,
                    y: y,
                    value: this.selectedTool === 'input' ? false : null,
                    inputs: [],
                    outputs: []
                };

                this.components.push(component);
                this.logAction(`‚úÖ Placed ${this.selectedTool} component`);
                this.updateStats();
                this.updateInputControls();
                this.render();
            }

            createConnection(from, to) {
                // Prevent duplicate connections
                const exists = this.connections.some(conn => 
                    (conn.from === from && conn.to === to) ||
                    (conn.from === to && conn.to === from)
                );

                if (!exists) {
                    this.connections.push({
                        from: from,
                        to: to,
                        id: this.nextId++
                    });
                    
                    // Update component references
                    from.outputs.push(to);
                    to.inputs.push(from);
                    
                    this.logAction(`üîó Connected ${from.type} to ${to.type}`);
                    this.updateStats();
                    this.render();
                } else {
                    this.logAction("‚ùå Connection already exists");
                }
            }

            getComponentAt(x, y) {
                return this.components.find(comp => {
                    const distance = Math.sqrt((comp.x - x) ** 2 + (comp.y - y) ** 2);
                    return distance < 25;
                });
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < this.canvas.width; i += 20) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let i = 0; i < this.canvas.height; i += 20) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i);
                    this.ctx.lineTo(this.canvas.width, i);
                    this.ctx.stroke();
                }

                // Draw connections
                this.ctx.strokeStyle = '#ff6b35';
                this.ctx.lineWidth = 2;
                this.connections.forEach(conn => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(conn.from.x, conn.from.y);
                    this.ctx.lineTo(conn.to.x, conn.to.y);
                    this.ctx.stroke();
                });

                // Draw components
                this.components.forEach(comp => this.drawComponent(comp));

                // Draw connection preview
                if (this.isConnecting && this.connectionStart) {
                    this.ctx.strokeStyle = 'rgba(255, 107, 53, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.connectionStart.x, this.connectionStart.y);
                    this.ctx.lineTo(this.mouseX || 0, this.mouseY || 0);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }

            drawComponent(comp) {
                const size = 20;
                
                // Component background
                this.ctx.fillStyle = comp.value === true ? '#00ff00' : 
                                   comp.value === false ? '#ff0000' : '#444';
                
                switch (comp.type) {
                    case 'input':
                        this.ctx.fillRect(comp.x - size/2, comp.y - size/2, size, size);
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = '12px Arial';
                        this.ctx.fillText('IN', comp.x - 10, comp.y + 4);
                        break;
                        
                    case 'output':
                        this.ctx.fillRect(comp.x - size/2, comp.y - size/2, size, size);
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = '12px Arial';
                        this.ctx.fillText('OUT', comp.x - 12, comp.y + 4);
                        break;
                        
                    case 'and':
                        this.drawGate(comp, 'AND');
                        break;
                        
                    case 'or':
                        this.drawGate(comp, 'OR');
                        break;
                        
                    case 'not':
                        this.drawGate(comp, 'NOT');
                        break;
                        
                    case 'nand':
                        this.drawGate(comp, 'NAND');
                        break;
                        
                    case 'nor':
                        this.drawGate(comp, 'NOR');
                        break;
                        
                    case 'xor':
                        this.drawGate(comp, 'XOR');
                        break;
                }
            }

            drawGate(comp, label) {
                const size = 30;
                this.ctx.fillRect(comp.x - size/2, comp.y - size/2, size, size);
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(label, comp.x, comp.y + 3);
                this.ctx.textAlign = 'start';
            }

            handleCanvasMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouseX = e.clientX - rect.left;
                this.mouseY = e.clientY - rect.top;
                
                if (this.isConnecting) {
                    this.render();
                }
            }

            simulate() {
                const inputs = this.components.filter(c => c.type === 'input');
                const outputs = this.components.filter(c => c.type === 'output');
                
                if (inputs.length === 0) {
                    this.logAction("‚ùå No inputs found for simulation");
                    return;
                }
                
                if (outputs.length === 0) {
                    this.logAction("‚ùå No outputs found for simulation");
                    return;
                }

                // Reset all component values except inputs
                this.components.forEach(comp => {
                    if (comp.type !== 'input') {
                        comp.value = null;
                    }
                });

                // Simulate logic propagation
                let changed = true;
                let iterations = 0;
                while (changed && iterations < 10) {
                    changed = false;
                    iterations++;
                    
                    this.components.forEach(comp => {
                        const oldValue = comp.value;
                        comp.value = this.calculateComponentValue(comp);
                        if (comp.value !== oldValue) {
                            changed = true;
                        }
                    });
                }

                // Display results
                const results = outputs.map(output => ({
                    id: output.id,
                    value: output.value
                }));

                const outputDisplay = document.getElementById('outputDisplay');
                outputDisplay.innerHTML = results.map(r => 
                    `Output ${r.id}: ${r.value === null ? 'NULL' : r.value ? 'HIGH (1)' : 'LOW (0)'}`
                ).join('<br>');

                this.logAction(`üî¨ Simulation complete (${iterations} iterations)`);
                this.render();
            }

            calculateComponentValue(comp) {
                if (comp.type === 'input') {
                    return comp.value; // Input values are set manually
                }

                const inputValues = comp.inputs.map(input => input.value);
                
                // If any input is null, output is null (except for NOT gate)
                if (inputValues.some(v => v === null) && comp.type !== 'not') {
                    return null;
                }

                switch (comp.type) {
                    case 'and':
                        return inputValues.every(v => v === true);
                        
                    case 'or':
                        return inputValues.some(v => v === true);
                        
                    case 'not':
                        return inputValues.length > 0 ? !inputValues[0] : null;
                        
                    case 'nand':
                        return !inputValues.every(v => v === true);
                        
                    case 'nor':
                        return !inputValues.some(v => v === true);
                        
                    case 'xor':
                        return inputValues.filter(v => v === true).length === 1;
                        
                    case 'output':
                        return inputValues.length > 0 ? inputValues[0] : null;
                        
                    default:
                        return null;
                }
            }

            updateInputControls() {
                const inputControls = document.getElementById('inputControls');
                const inputs = this.components.filter(c => c.type === 'input');
                
                inputControls.innerHTML = '';
                
                inputs.forEach(input => {
                    const controlDiv = document.createElement('div');
                    controlDiv.className = 'input-control';
                    
                    const label = document.createElement('div');
                    label.className = 'input-label';
                    label.textContent = `Input ${input.id}`;
                    
                    const switchLabel = document.createElement('label');
                    switchLabel.className = 'switch';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = input.value;
                    checkbox.addEventListener('change', (e) => {
                        input.value = e.target.checked;
                        this.logAction(`üîß Input ${input.id} set to ${input.value ? 'HIGH' : 'LOW'}`);
                        this.render();
                    });
                    
                    const slider = document.createElement('span');
                    slider.className = 'slider';
                    
                    switchLabel.appendChild(checkbox);
                    switchLabel.appendChild(slider);
                    
                    controlDiv.appendChild(label);
                    controlDiv.appendChild(switchLabel);
                    inputControls.appendChild(controlDiv);
                });
            }

            clearCanvas() {
                this.components = [];
                this.connections = [];
                this.isConnecting = false;
                this.connectionStart = null;
                this.nextId = 1;
                this.updateStats();
                this.updateInputControls();
                document.getElementById('outputDisplay').innerHTML = 'No outputs connected';
                this.render();
                this.logAction("üßπ Circuit cleared");
            }

            loadExample() {
                this.clearCanvas();
                
                // Create a simple AND gate circuit
                const input1 = { id: 1, type: 'input', x: 100, y: 150, value: false, inputs: [], outputs: [] };
                const input2 = { id: 2, type: 'input', x: 100, y: 250, value: false, inputs: [], outputs: [] };
                const andGate = { id: 3, type: 'and', x: 250, y: 200, value: null, inputs: [], outputs: [] };
                const output = { id: 4, type: 'output', x: 400, y: 200, value: null, inputs: [], outputs: [] };
                
                this.components = [input1, input2, andGate, output];
                this.nextId = 5;
                
                this.createConnection(input1, andGate);
                this.createConnection(input2, andGate);
                this.createConnection(andGate, output);
                
                this.updateStats();
                this.updateInputControls();
                this.render();
                this.logAction("üìã Example AND gate circuit loaded");
            }

            validateCircuit() {
                const inputs = this.components.filter(c => c.type === 'input');
                const outputs = this.components.filter(c => c.type === 'output');
                const gates = this.components.filter(c => !['input', 'output'].includes(c.type));
                
                let errors = [];
                
                if (inputs.length === 0) errors.push("No input components");
                if (outputs.length === 0) errors.push("No output components");
                
                // Check for disconnected components
                this.components.forEach(comp => {
                    if (comp.type !== 'input' && comp.inputs.length === 0) {
                        errors.push(`${comp.type} (${comp.id}) has no inputs`);
                    }
                    if (comp.type !== 'output' && comp.outputs.length === 0) {
                        errors.push(`${comp.type} (${comp.id}) has no outputs`);
                    }
                });
                
                if (errors.length === 0) {
                    this.logAction("‚úÖ Circuit validation passed!");
                } else {
                    errors.forEach(error => this.logAction(`‚ùå ${error}`));
                }
            }

            updateStats() {
                document.getElementById('componentCount').textContent = this.components.length;
                document.getElementById('connectionCount').textContent = this.connections.length;
                document.getElementById('inputCount').textContent = this.components.filter(c => c.type === 'input').length;
                document.getElementById('outputCount').textContent = this.components.filter(c => c.type === 'output').length;
            }

            logAction(message) {
                const log = document.getElementById('gameLog');
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                log.insertBefore(entry, log.firstChild);
                
                // Keep only last 15 entries
                while (log.children.length > 15) {
                    log.removeChild(log.lastChild);
                }
            }
        }

        // Initialize the game when page loads
        let game;
        window.addEventListener('load', () => {
            game = new LogicCircuitBuilder();
        });
    </script>
</body>
</html>