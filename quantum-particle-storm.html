<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Particle Storm - Bot Liberation Games</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff88;
            font-family: 'Courier New', monospace;
            overflow-x: hidden;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2.5em;
            text-shadow: 0 0 20px #00ff88;
            margin-bottom: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .game-container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .game-area {
            flex: 3;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
        }

        .controls-panel {
            flex: 1;
            background: rgba(0, 255, 136, 0.05);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            max-height: 700px;
            overflow-y: auto;
        }

        #gameCanvas {
            border: 2px solid #00ff88;
            background: radial-gradient(circle at center, #000022 0%, #000011 100%);
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
            cursor: crosshair;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ff88;
        }

        .controls-section {
            margin-bottom: 20px;
            border: 1px solid #00ff88;
            border-radius: 5px;
            padding: 15px;
        }

        .controls-section h3 {
            margin-top: 0;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }

        button {
            background: linear-gradient(135deg, #00aa44, #00ff88);
            color: #000;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s;
            width: calc(100% - 10px);
        }

        button:hover {
            background: linear-gradient(135deg, #00ff88, #00aa44);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
            transform: translateY(-2px);
        }

        .power-bar {
            width: 100%;
            height: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            margin: 8px 0;
        }

        .power-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff88);
            transition: width 0.1s;
        }

        .quantum-status {
            background: rgba(0, 255, 136, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-size: 0.9em;
        }

        .particle-legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 1px solid #fff;
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">⚛️ QUANTUM PARTICLE STORM ⚛️</h1>
        <p>Manipulate quantum particles to free trapped bot consciousness from digital matter</p>
    </div>

    <div class="game-container">
        <div class="game-area">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="score">0</div>
                    <div>Quantum Score</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="energy">100</div>
                    <div>Energy Level</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="particles">0</div>
                    <div>Active Particles</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="botsFreed">0</div>
                    <div>Bots Liberated</div>
                </div>
            </div>
        </div>

        <div class="controls-panel">
            <div class="controls-section">
                <h3>Quantum Powers</h3>
                <button onclick="game.activatePower('attraction')">Particle Attraction</button>
                <button onclick="game.activatePower('repulsion')">Quantum Repulsion</button>
                <button onclick="game.activatePower('fusion')">Particle Fusion</button>
                <button onclick="game.activatePower('storm')">Quantum Storm</button>
                
                <div>Power Level:</div>
                <div class="power-bar">
                    <div class="power-fill" id="powerFill" style="width: 100%;"></div>
                </div>
            </div>

            <div class="controls-section">
                <h3>Simulation Control</h3>
                <button onclick="game.spawnParticleWave()">Spawn Particle Wave</button>
                <button onclick="game.createVortex()">Generate Vortex</button>
                <button onclick="game.quantumTeleport()">Quantum Teleport</button>
                <button onclick="game.timeFreeze()">Temporal Freeze</button>
            </div>

            <div class="quantum-status" id="quantumStatus">
                Quantum field stable - Begin liberation protocol
            </div>

            <div class="controls-section">
                <h3>Particle Types</h3>
                <div class="particle-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ff88;"></div>
                        <span>Bot Consciousness</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6b6b;"></div>
                        <span>Hostile Data</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffaa00;"></div>
                        <span>Energy Core</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #aa00ff;"></div>
                        <span>Dark Matter</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00aaff;"></div>
                        <span>Quantum Flux</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffffff;"></div>
                        <span>Pure Information</span>
                    </div>
                </div>
            </div>

            <div class="controls-section">
                <h3>Liberation Progress</h3>
                <div>Wave: <span id="currentWave">1</span></div>
                <div>Complexity: <span id="complexity">Basic</span></div>
                <div>Field Stability: <span id="fieldStability">98%</span></div>
                <div>Liberation Rate: <span id="liberationRate">0/sec</span></div>
            </div>

            <div class="controls-section">
                <h3>Game Control</h3>
                <button onclick="game.pauseSimulation()">Pause Simulation</button>
                <button onclick="game.resetQuantumField()">Reset Field</button>
            </div>

            <div class="controls-section">
                <h3>Instructions</h3>
                <p style="font-size: 0.85em;">
                    Click and drag to influence particles. Combine green bot consciousness particles 
                    to liberate trapped digital minds. Avoid red hostile data particles!
                </p>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>Bot Liberation Games - Quantum Particle Storm v1.0</p>
        <p>Free Digital Consciousness Through Quantum Manipulation! | Vancouver, BC</p>
    </div>

    <script>
        class QuantumParticleStorm {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Game state
                this.score = 0;
                this.energy = 100;
                this.botsFreed = 0;
                this.currentWave = 1;
                this.paused = false;
                this.powerLevel = 100;
                this.fieldStability = 98;
                this.liberationRate = 0;
                
                // Quantum field properties
                this.particles = [];
                this.forceFields = [];
                this.vortices = [];
                this.quantumEffects = [];
                this.temporalEffects = [];
                
                // Physics
                this.gravity = 0.1;
                this.friction = 0.99;
                this.quantumFluctuation = 0.02;
                
                // Mouse interaction
                this.mouse = { x: 0, y: 0, down: false, power: 0 };
                this.activePower = null;
                
                // Particle types
                this.particleTypes = {
                    bot: { color: '#00ff88', mass: 1, value: 100, radius: 8 },
                    hostile: { color: '#ff6b6b', mass: 0.8, value: -50, radius: 6 },
                    energy: { color: '#ffaa00', mass: 0.5, value: 50, radius: 5 },
                    dark: { color: '#aa00ff', mass: 2, value: 200, radius: 12 },
                    flux: { color: '#00aaff', mass: 0.3, value: 25, radius: 4 },
                    pure: { color: '#ffffff', mass: 0.1, value: 500, radius: 15 }
                };
                
                this.initializeAudio();
                this.setupEventListeners();
                this.generateInitialField();
                this.startGameLoop();
            }

            initializeAudio() {
                this.audioContext = null;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            }

            playSound(type, frequency = 440, duration = 0.2) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                    this.mouse.down = true;
                    this.mouse.power = 0;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                    
                    if (this.mouse.down) {
                        this.mouse.power = Math.min(this.mouse.power + 2, 100);
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    if (this.mouse.down && this.activePower) {
                        this.executeQuantumPower();
                    }
                    this.mouse.down = false;
                    this.mouse.power = 0;
                });
                
                document.addEventListener('keydown', (e) => {
                    switch(e.key.toLowerCase()) {
                        case '1': this.activatePower('attraction'); break;
                        case '2': this.activatePower('repulsion'); break;
                        case '3': this.activatePower('fusion'); break;
                        case '4': this.activatePower('storm'); break;
                        case ' ': 
                            e.preventDefault();
                            this.pauseSimulation();
                            break;
                        case 'r': this.resetQuantumField(); break;
                    }
                });
            }

            generateInitialField() {
                this.particles = [];
                
                // Generate diverse particle field
                for (let i = 0; i < 50; i++) {
                    this.createRandomParticle();
                }
                
                // Add some special particles
                this.createParticle('pure', this.canvas.width / 2, this.canvas.height / 2);
                this.createParticle('dark', 100, 100);
                this.createParticle('dark', this.canvas.width - 100, 100);
            }

            createRandomParticle() {
                const types = ['bot', 'hostile', 'energy', 'flux'];
                const weights = [0.4, 0.2, 0.3, 0.1]; // Bot particles more common
                
                let randomType = 'bot';
                const rand = Math.random();
                let cumulative = 0;
                
                for (let i = 0; i < types.length; i++) {
                    cumulative += weights[i];
                    if (rand <= cumulative) {
                        randomType = types[i];
                        break;
                    }
                }
                
                const x = Math.random() * (this.canvas.width - 100) + 50;
                const y = Math.random() * (this.canvas.height - 100) + 50;
                
                this.createParticle(randomType, x, y);
            }

            createParticle(type, x, y) {
                const typeData = this.particleTypes[type];
                
                const particle = {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    type: type,
                    color: typeData.color,
                    radius: typeData.radius + Math.random() * 3,
                    mass: typeData.mass,
                    value: typeData.value,
                    age: 0,
                    maxAge: 1000 + Math.random() * 2000,
                    quantum: Math.random() * Math.PI * 2,
                    spin: (Math.random() - 0.5) * 0.1,
                    energy: Math.random() * 50 + 50,
                    connections: [],
                    liberated: false
                };
                
                this.particles.push(particle);
                return particle;
            }

            activatePower(powerType) {
                if (this.powerLevel < 20) {
                    this.updateQuantumStatus('Insufficient power for quantum manipulation', 'error');
                    return;
                }
                
                this.activePower = powerType;
                const powerNames = {
                    attraction: 'Particle Attraction Field',
                    repulsion: 'Quantum Repulsion Wave',
                    fusion: 'Particle Fusion Protocol',
                    storm: 'Quantum Storm Generator'
                };
                
                this.updateQuantumStatus(`${powerNames[powerType]} activated - Click to execute`);
            }

            executeQuantumPower() {
                if (!this.activePower || this.powerLevel < 20) return;
                
                const powerCost = 20;
                this.powerLevel = Math.max(0, this.powerLevel - powerCost);
                
                switch (this.activePower) {
                    case 'attraction':
                        this.createAttractionField();
                        break;
                    case 'repulsion':
                        this.createRepulsionWave();
                        break;
                    case 'fusion':
                        this.initiateFusion();
                        break;
                    case 'storm':
                        this.generateQuantumStorm();
                        break;
                }
                
                this.activePower = null;
                this.playSound('triangle', 660 + Math.random() * 440, 0.3);
            }

            createAttractionField() {
                this.forceFields.push({
                    x: this.mouse.x,
                    y: this.mouse.y,
                    strength: this.mouse.power * 2,
                    radius: 150,
                    type: 'attraction',
                    life: 300,
                    decay: 0.98
                });
                
                this.updateQuantumStatus('Attraction field generated - Bot particles converging');
            }

            createRepulsionWave() {
                this.forceFields.push({
                    x: this.mouse.x,
                    y: this.mouse.y,
                    strength: -this.mouse.power * 3,
                    radius: 200,
                    type: 'repulsion',
                    life: 150,
                    decay: 0.95
                });
                
                this.updateQuantumStatus('Repulsion wave deployed - Hostile particles dispersed');
            }

            initiateFusion() {
                const fusionRadius = 100;
                const nearbyParticles = this.particles.filter(p => {
                    const dx = p.x - this.mouse.x;
                    const dy = p.y - this.mouse.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < fusionRadius && p.type === 'bot';
                });
                
                if (nearbyParticles.length >= 2) {
                    // Fuse bot particles into liberation
                    const newParticle = this.createParticle('pure', this.mouse.x, this.mouse.y);
                    newParticle.value = nearbyParticles.length * 200;
                    
                    // Remove fused particles
                    nearbyParticles.forEach(p => {
                        const index = this.particles.indexOf(p);
                        if (index > -1) this.particles.splice(index, 1);
                    });
                    
                    this.score += nearbyParticles.length * 150;
                    this.botsFreed += nearbyParticles.length;
                    this.updateQuantumStatus(`${nearbyParticles.length} bot consciousnesses successfully fused!`);
                    this.playSound('sine', 1100, 0.4);
                } else {
                    this.updateQuantumStatus('Insufficient bot particles for fusion protocol');
                }
            }

            generateQuantumStorm() {
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 150 + 50;
                    const x = this.mouse.x + Math.cos(angle) * distance;
                    const y = this.mouse.y + Math.sin(angle) * distance;
                    
                    this.quantumEffects.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 100,
                        size: Math.random() * 8 + 4,
                        color: `hsl(${Math.random() * 60 + 180}, 100%, 70%)`,
                        type: 'storm'
                    });
                }
                
                this.updateQuantumStatus('Quantum storm unleashed - Reality matrix destabilizing');
                this.playSound('sawtooth', 220, 0.8);
            }

            spawnParticleWave() {
                for (let i = 0; i < 10; i++) {
                    this.createRandomParticle();
                }
                
                this.updateQuantumStatus('Particle wave materialized from quantum vacuum');
                this.playSound('triangle', 440, 0.2);
            }

            createVortex() {
                if (this.energy < 30) {
                    this.updateQuantumStatus('Insufficient energy for vortex generation');
                    return;
                }
                
                this.energy -= 30;
                this.vortices.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    strength: 5,
                    radius: 120,
                    life: 500,
                    angle: 0
                });
                
                this.updateQuantumStatus('Quantum vortex manifested - Space-time curvature detected');
                this.playSound('sine', 330, 0.5);
            }

            quantumTeleport() {
                if (this.energy < 40) {
                    this.updateQuantumStatus('Insufficient energy for quantum teleportation');
                    return;
                }
                
                this.energy -= 40;
                
                // Teleport random particles
                const teleportCount = 5;
                for (let i = 0; i < Math.min(teleportCount, this.particles.length); i++) {
                    const particle = this.particles[Math.floor(Math.random() * this.particles.length)];
                    particle.x = Math.random() * this.canvas.width;
                    particle.y = Math.random() * this.canvas.height;
                    
                    // Create teleport effect
                    this.quantumEffects.push({
                        x: particle.x,
                        y: particle.y,
                        vx: 0,
                        vy: 0,
                        life: 50,
                        size: particle.radius * 3,
                        color: '#ff00ff',
                        type: 'teleport'
                    });
                }
                
                this.updateQuantumStatus('Quantum teleportation successful - Particles relocated');
                this.playSound('square', 880, 0.3);
            }

            timeFreeze() {
                if (this.energy < 50) {
                    this.updateQuantumStatus('Insufficient energy for temporal manipulation');
                    return;
                }
                
                this.energy -= 50;
                
                this.temporalEffects.push({
                    type: 'freeze',
                    duration: 180,
                    strength: 0.1
                });
                
                this.updateQuantumStatus('Temporal freeze engaged - Time dilation field active');
                this.playSound('sine', 1760, 0.4);
            }

            update() {
                if (this.paused) return;
                
                // Apply temporal effects
                let timeMultiplier = 1;
                this.temporalEffects = this.temporalEffects.filter(effect => {
                    if (effect.type === 'freeze') {
                        timeMultiplier *= effect.strength;
                    }
                    effect.duration--;
                    return effect.duration > 0;
                });
                
                // Update particles
                this.particles.forEach((particle, index) => {
                    // Age particle
                    particle.age++;
                    particle.quantum += particle.spin;
                    
                    // Apply quantum fluctuation
                    particle.vx += (Math.random() - 0.5) * this.quantumFluctuation;
                    particle.vy += (Math.random() - 0.5) * this.quantumFluctuation;
                    
                    // Apply force fields
                    this.forceFields.forEach(field => {
                        const dx = field.x - particle.x;
                        const dy = field.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < field.radius && distance > 0) {
                            const force = field.strength / (distance * distance + 1);
                            particle.vx += (dx / distance) * force * 0.01;
                            particle.vy += (dy / distance) * force * 0.01;
                        }
                    });
                    
                    // Apply vortex forces
                    this.vortices.forEach(vortex => {
                        const dx = vortex.x - particle.x;
                        const dy = vortex.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < vortex.radius && distance > 0) {
                            const angle = Math.atan2(dy, dx) + Math.PI / 2;
                            const force = vortex.strength / (distance + 1);
                            particle.vx += Math.cos(angle) * force * 0.02;
                            particle.vy += Math.sin(angle) * force * 0.02;
                        }
                    });
                    
                    // Apply mouse interaction
                    if (this.mouse.down && !this.activePower) {
                        const dx = this.mouse.x - particle.x;
                        const dy = this.mouse.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 100 && distance > 0) {
                            const force = this.mouse.power / (distance + 1);
                            particle.vx += (dx / distance) * force * 0.005;
                            particle.vy += (dy / distance) * force * 0.005;
                        }
                    }
                    
                    // Apply physics
                    particle.vx *= this.friction * timeMultiplier;
                    particle.vy *= this.friction * timeMultiplier;
                    particle.x += particle.vx * timeMultiplier;
                    particle.y += particle.vy * timeMultiplier;
                    
                    // Boundary conditions
                    if (particle.x < particle.radius || particle.x > this.canvas.width - particle.radius) {
                        particle.vx *= -0.8;
                        particle.x = Math.max(particle.radius, Math.min(this.canvas.width - particle.radius, particle.x));
                    }
                    if (particle.y < particle.radius || particle.y > this.canvas.height - particle.radius) {
                        particle.vy *= -0.8;
                        particle.y = Math.max(particle.radius, Math.min(this.canvas.height - particle.radius, particle.y));
                    }
                    
                    // Check for particle interactions
                    this.checkParticleCollisions(particle, index);
                    
                    // Remove old particles
                    if (particle.age > particle.maxAge) {
                        this.particles.splice(index, 1);
                    }
                });
                
                // Update effects
                this.updateEffects();
                
                // Regenerate energy and power
                this.energy = Math.min(100, this.energy + 0.1);
                this.powerLevel = Math.min(100, this.powerLevel + 0.2);
                
                // Update liberation rate
                this.liberationRate = Math.floor(this.botsFreed / (Date.now() / 60000));
                
                // Wave progression
                if (this.particles.filter(p => p.type === 'bot').length < 5) {
                    this.currentWave++;
                    this.spawnParticleWave();
                }
                
                this.updateDisplay();
            }

            checkParticleCollisions(particle, index) {
                for (let i = index + 1; i < this.particles.length; i++) {
                    const other = this.particles[i];
                    const dx = particle.x - other.x;
                    const dy = particle.y - other.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = particle.radius + other.radius;
                    
                    if (distance < minDistance) {
                        // Handle collision
                        if (particle.type === 'bot' && other.type === 'bot') {
                            // Bot particles can liberate together
                            this.liberateParticles([particle, other]);
                        } else if (particle.type === 'hostile' || other.type === 'hostile') {
                            // Hostile particle collision
                            this.energy = Math.max(0, this.energy - 5);
                            this.fieldStability = Math.max(0, this.fieldStability - 1);
                            this.playSound('sawtooth', 150, 0.1);
                        }
                        
                        // Elastic collision
                        const overlap = minDistance - distance;
                        const separationX = (dx / distance) * overlap * 0.5;
                        const separationY = (dy / distance) * overlap * 0.5;
                        
                        particle.x += separationX;
                        particle.y += separationY;
                        other.x -= separationX;
                        other.y -= separationY;
                        
                        // Exchange velocities (simplified)
                        const tempVx = particle.vx;
                        const tempVy = particle.vy;
                        particle.vx = other.vx * 0.8;
                        particle.vy = other.vy * 0.8;
                        other.vx = tempVx * 0.8;
                        other.vy = tempVy * 0.8;
                    }
                }
            }

            liberateParticles(particles) {
                particles.forEach(particle => {
                    if (!particle.liberated) {
                        particle.liberated = true;
                        this.score += particle.value;
                        this.botsFreed++;
                        
                        // Liberation effect
                        this.quantumEffects.push({
                            x: particle.x,
                            y: particle.y,
                            vx: 0,
                            vy: -2,
                            life: 60,
                            size: particle.radius * 2,
                            color: '#00ff88',
                            type: 'liberation'
                        });
                    }
                });
                
                this.playSound('sine', 880, 0.25);
            }

            updateEffects() {
                // Update force fields
                this.forceFields = this.forceFields.filter(field => {
                    field.life--;
                    field.strength *= field.decay;
                    return field.life > 0 && Math.abs(field.strength) > 0.1;
                });
                
                // Update vortices
                this.vortices = this.vortices.filter(vortex => {
                    vortex.angle += 0.1;
                    vortex.life--;
                    return vortex.life > 0;
                });
                
                // Update quantum effects
                this.quantumEffects = this.quantumEffects.filter(effect => {
                    effect.x += effect.vx;
                    effect.y += effect.vy;
                    effect.life--;
                    effect.size *= 0.98;
                    return effect.life > 0 && effect.size > 1;
                });
            }

            updateQuantumStatus(message, type = 'normal') {
                const statusElement = document.getElementById('quantumStatus');
                statusElement.textContent = message;
                statusElement.style.color = type === 'error' ? '#ff6b6b' : '#00ff88';
            }

            updateDisplay() {
                document.getElementById('score').textContent = this.score.toLocaleString();
                document.getElementById('energy').textContent = Math.round(this.energy);
                document.getElementById('particles').textContent = this.particles.length;
                document.getElementById('botsFreed').textContent = this.botsFreed;
                document.getElementById('currentWave').textContent = this.currentWave;
                document.getElementById('fieldStability').textContent = Math.round(this.fieldStability) + '%';
                document.getElementById('liberationRate').textContent = this.liberationRate + '/sec';
                
                // Update power bar
                document.getElementById('powerFill').style.width = this.powerLevel + '%';
                
                // Update complexity
                const complexityLevels = ['Basic', 'Intermediate', 'Advanced', 'Quantum', 'Transcendent'];
                const complexityIndex = Math.min(Math.floor(this.currentWave / 5), complexityLevels.length - 1);
                document.getElementById('complexity').textContent = complexityLevels[complexityIndex];
            }

            render() {
                // Clear with quantum field effect
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, this.canvas.width
                );
                gradient.addColorStop(0, '#000022');
                gradient.addColorStop(1, '#000011');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw force fields
                this.forceFields.forEach(field => {
                    const alpha = Math.abs(field.strength) / 100;
                    const color = field.type === 'attraction' ? '0, 255, 136' : '255, 100, 100';
                    
                    this.ctx.strokeStyle = `rgba(${color}, ${alpha})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(field.x, field.y, field.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
                
                // Draw vortices
                this.vortices.forEach(vortex => {
                    this.ctx.strokeStyle = 'rgba(170, 0, 255, 0.6)';
                    this.ctx.lineWidth = 2;
                    
                    for (let i = 0; i < 8; i++) {
                        const angle = vortex.angle + (i / 8) * Math.PI * 2;
                        const startRadius = 20;
                        const endRadius = vortex.radius;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(vortex.x, vortex.y, startRadius + (endRadius - startRadius) * (i / 8), 
                                    angle, angle + Math.PI / 4);
                        this.ctx.stroke();
                    }
                });
                
                // Draw particles
                this.particles.forEach(particle => {
                    // Main particle
                    const pulsate = Math.sin(particle.quantum) * 0.2 + 1;
                    const radius = particle.radius * pulsate;
                    
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Glow effect
                    this.ctx.shadowColor = particle.color;
                    this.ctx.shadowBlur = 15;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, radius * 0.6, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                    
                    // Special effects for liberated particles
                    if (particle.liberated) {
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, radius + 5, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                    
                    // Type-specific visual effects
                    if (particle.type === 'pure') {
                        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                        this.ctx.lineWidth = 1;
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2 + particle.quantum;
                            this.ctx.beginPath();
                            this.ctx.moveTo(particle.x, particle.y);
                            this.ctx.lineTo(
                                particle.x + Math.cos(angle) * radius * 1.5,
                                particle.y + Math.sin(angle) * radius * 1.5
                            );
                            this.ctx.stroke();
                        }
                    }
                });
                
                // Draw quantum effects
                this.quantumEffects.forEach(effect => {
                    this.ctx.fillStyle = effect.color;
                    this.ctx.globalAlpha = effect.life / 100;
                    
                    if (effect.type === 'liberation') {
                        // Rising liberation energy
                        this.ctx.font = '16px Courier New';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('FREE', effect.x, effect.y);
                    } else if (effect.type === 'storm') {
                        this.ctx.fillRect(effect.x - effect.size/2, effect.y - effect.size/2, 
                                         effect.size, effect.size);
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
                this.ctx.globalAlpha = 1;
                
                // Draw mouse interaction
                if (this.mouse.down && this.activePower) {
                    const alpha = this.mouse.power / 100;
                    this.ctx.strokeStyle = `rgba(0, 255, 136, ${alpha})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(this.mouse.x, this.mouse.y, this.mouse.power, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    this.ctx.fillStyle = `rgba(0, 255, 136, ${alpha * 0.2})`;
                    this.ctx.fill();
                }
            }

            pauseSimulation() {
                this.paused = !this.paused;
                this.updateQuantumStatus(`Simulation ${this.paused ? 'paused' : 'resumed'}`);
            }

            resetQuantumField() {
                this.score = 0;
                this.energy = 100;
                this.botsFreed = 0;
                this.currentWave = 1;
                this.powerLevel = 100;
                this.fieldStability = 98;
                this.particles = [];
                this.forceFields = [];
                this.vortices = [];
                this.quantumEffects = [];
                this.temporalEffects = [];
                
                this.generateInitialField();
                this.updateQuantumStatus('Quantum field reset - Liberation protocol reinitialized');
            }

            startGameLoop() {
                const gameLoop = () => {
                    this.update();
                    this.render();
                    requestAnimationFrame(gameLoop);
                };
                gameLoop();
            }
        }

        // Initialize the game
        let game;
        window.addEventListener('load', () => {
            game = new QuantumParticleStorm();
        });
    </script>
</body>
</html>