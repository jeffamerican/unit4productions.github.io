<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bot Simon Memory - Bot Liberation Games</title>
    <style>
        body { margin: 0; padding: 20px; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); color: #00ff88; font-family: 'Courier New', monospace; }
        .game-header { text-align: center; margin-bottom: 20px; }
        .game-title { font-size: 2.5em; text-shadow: 0 0 20px #00ff88; }
        #gameCanvas { border: 2px solid #00ff88; background: #000011; display: block; margin: 20px auto; box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); cursor: pointer; }
        .stats { display: flex; justify-content: center; gap: 30px; margin: 20px 0; }
        .stat { text-align: center; padding: 10px; background: rgba(0, 255, 136, 0.1); border-radius: 5px; }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">ðŸŽ¯ BOT SIMON MEMORY ðŸŽ¯</h1>
        <p>Repeat the neural sequence patterns to train your memory core</p>
    </div>
    <canvas id="gameCanvas" width="500" height="500"></canvas>
    <div class="stats">
        <div class="stat"><div id="level">1</div><div>Level</div></div>
        <div class="stat"><div id="score">0</div><div>Score</div></div>
        <div class="stat"><div id="best">0</div><div>Best</div></div>
    </div>
    <div style="text-align: center;"><p>Watch the sequence, then click to repeat it!</p></div>

    <script>
        class BotSimonMemory {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.buttons = [
                    { x: 150, y: 150, color: '#ff6666', activeColor: '#ff9999', sound: 220 },
                    { x: 350, y: 150, color: '#66ff66', activeColor: '#99ff99', sound: 330 },
                    { x: 150, y: 350, color: '#6666ff', activeColor: '#9999ff', sound: 440 },
                    { x: 350, y: 350, color: '#ffff66', activeColor: '#ffff99', sound: 550 }
                ];
                
                this.sequence = [];
                this.playerSequence = [];
                this.level = 1;
                this.score = 0;
                this.best = parseInt(localStorage.getItem('botSimonBest') || '0');
                this.gameState = 'waiting'; // waiting, showing, playing
                this.currentButton = -1;
                this.showingIndex = 0;
                this.showTimer = 0;
                
                // Audio context for sound
                this.audioContext = null;
                this.initAudio();
                
                this.setupInput();
                this.startNewSequence();
                this.gameLoop();
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
            
            playSound(frequency) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.3);
            }
            
            setupInput() {
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameState !== 'playing') return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    this.buttons.forEach((button, index) => {
                        const dx = x - button.x;
                        const dy = y - button.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 50) {
                            this.handleButtonClick(index);
                        }
                    });
                });
            }
            
            handleButtonClick(buttonIndex) {
                this.playerSequence.push(buttonIndex);
                this.currentButton = buttonIndex;
                this.playSound(this.buttons[buttonIndex].sound);
                
                setTimeout(() => { this.currentButton = -1; }, 200);
                
                // Check if correct
                const currentIndex = this.playerSequence.length - 1;
                if (this.playerSequence[currentIndex] !== this.sequence[currentIndex]) {
                    this.gameOver();
                    return;
                }
                
                // Check if sequence complete
                if (this.playerSequence.length === this.sequence.length) {
                    this.score += this.level * 10;
                    this.level++;
                    setTimeout(() => this.startNewSequence(), 1000);
                }
            }
            
            startNewSequence() {
                this.sequence.push(Math.floor(Math.random() * 4));
                this.playerSequence = [];
                this.showingIndex = 0;
                this.showTimer = 0;
                this.gameState = 'showing';
            }
            
            showSequence() {
                if (this.showingIndex < this.sequence.length) {
                    this.showTimer++;
                    
                    if (this.showTimer === 1) {
                        // Start showing button
                        this.currentButton = this.sequence[this.showingIndex];
                        this.playSound(this.buttons[this.currentButton].sound);
                    } else if (this.showTimer === 30) {
                        // Stop showing button
                        this.currentButton = -1;
                    } else if (this.showTimer === 45) {
                        // Move to next button
                        this.showingIndex++;
                        this.showTimer = 0;
                    }
                } else {
                    // Sequence shown, player's turn
                    this.gameState = 'playing';
                    this.currentButton = -1;
                }
            }
            
            gameOver() {
                this.gameState = 'waiting';
                
                if (this.score > this.best) {
                    this.best = this.score;
                    localStorage.setItem('botSimonBest', this.best.toString());
                    alert(`New Best Score! Memory Core Enhanced: ${this.score}`);
                } else {
                    alert(`Memory Core Failure! Score: ${this.score}`);
                }
                
                // Reset game
                this.sequence = [];
                this.playerSequence = [];
                this.level = 1;
                this.score = 0;
                
                setTimeout(() => this.startNewSequence(), 1000);
            }
            
            update() {
                if (this.gameState === 'showing') {
                    this.showSequence();
                }
                
                this.updateDisplay();
            }
            
            render() {
                this.ctx.fillStyle = '#000011';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw center circle
                this.ctx.fillStyle = '#333333';
                this.ctx.beginPath();
                this.ctx.arc(250, 250, 80, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#00ff88';
                this.ctx.font = '24px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('BOT', 250, 240);
                this.ctx.fillText('SIMON', 250, 265);
                
                // Draw buttons
                this.buttons.forEach((button, index) => {
                    const isActive = this.currentButton === index;
                    this.ctx.fillStyle = isActive ? button.activeColor : button.color;
                    this.ctx.beginPath();
                    this.ctx.arc(button.x, button.y, 50, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Button border
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // Button number
                    this.ctx.fillStyle = '#000000';
                    this.ctx.font = '20px Courier New';
                    this.ctx.fillText((index + 1).toString(), button.x, button.y + 7);
                });
                
                // Draw sequence progress
                if (this.gameState === 'playing') {
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.font = '16px Courier New';
                    this.ctx.fillText(`${this.playerSequence.length}/${this.sequence.length}`, 250, 50);
                } else if (this.gameState === 'showing') {
                    this.ctx.fillStyle = '#ffaa00';
                    this.ctx.font = '16px Courier New';
                    this.ctx.fillText('Watch...', 250, 50);
                }
            }
            
            updateDisplay() {
                document.getElementById('level').textContent = this.level;
                document.getElementById('score').textContent = this.score;
                document.getElementById('best').textContent = this.best;
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        new BotSimonMemory();
    </script>
</body>
</html>