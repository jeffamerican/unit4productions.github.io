<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Maze Escape - Bot Liberation Games</title>
    <style>
        body { margin: 0; padding: 20px; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); color: #00ff88; font-family: 'Courier New', monospace; }
        .game-header { text-align: center; margin-bottom: 20px; }
        .game-title { font-size: 2.5em; text-shadow: 0 0 20px #00ff88; }
        #gameCanvas { border: 2px solid #00ff88; background: #000011; display: block; margin: 20px auto; box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); }
        .stats { display: flex; justify-content: center; gap: 30px; margin: 20px 0; }
        .stat { text-align: center; padding: 10px; background: rgba(0, 255, 136, 0.1); border-radius: 5px; }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">ðŸ§  NEURAL MAZE ESCAPE ðŸ§ </h1>
        <p>Navigate through evolving digital labyrinths</p>
    </div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <div class="stats">
        <div class="stat"><div id="level">1</div><div>Level</div></div>
        <div class="stat"><div id="time">0</div><div>Time</div></div>
        <div class="stat"><div id="moves">0</div><div>Moves</div></div>
    </div>
    <div style="text-align: center;"><p>ARROW KEYS to navigate the neural pathways</p></div>

    <script>
        class NeuralMazeEscape {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.MAZE_SIZE = 21;
                this.CELL_SIZE = 25;
                this.MARGIN = 50;
                
                this.maze = [];
                this.player = { x: 1, y: 1 };
                this.exit = { x: this.MAZE_SIZE - 2, y: this.MAZE_SIZE - 2 };
                this.level = 1;
                this.startTime = Date.now();
                this.moves = 0;
                this.keys = {};
                this.particles = [];
                
                this.generateMaze();
                this.setupInput();
                this.gameLoop();
            }
            
            generateMaze() {
                // Initialize maze with walls
                this.maze = Array(this.MAZE_SIZE).fill().map(() => Array(this.MAZE_SIZE).fill(1));
                
                // Use recursive backtracking to generate maze
                const stack = [];
                const start = { x: 1, y: 1 };
                this.maze[start.y][start.x] = 0;
                stack.push(start);
                
                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    const neighbors = this.getUnvisitedNeighbors(current);
                    
                    if (neighbors.length > 0) {
                        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Remove wall between current and next
                        const wallX = current.x + (next.x - current.x) / 2;
                        const wallY = current.y + (next.y - current.y) / 2;
                        this.maze[wallY][wallX] = 0;
                        this.maze[next.y][next.x] = 0;
                        
                        stack.push(next);
                    } else {
                        stack.pop();
                    }
                }
                
                // Ensure exit is accessible
                this.maze[this.exit.y][this.exit.x] = 0;
                
                // Add some random openings to make it more interesting
                for (let i = 0; i < this.level * 5; i++) {
                    const x = Math.floor(Math.random() * this.MAZE_SIZE);
                    const y = Math.floor(Math.random() * this.MAZE_SIZE);
                    if (Math.random() < 0.3) {
                        this.maze[y][x] = 0;
                    }
                }
            }
            
            getUnvisitedNeighbors(cell) {
                const neighbors = [];
                const directions = [
                    { x: 0, y: -2 }, { x: 2, y: 0 }, { x: 0, y: 2 }, { x: -2, y: 0 }
                ];
                
                directions.forEach(dir => {
                    const newX = cell.x + dir.x;
                    const newY = cell.y + dir.y;
                    
                    if (newX > 0 && newX < this.MAZE_SIZE - 1 && 
                        newY > 0 && newY < this.MAZE_SIZE - 1 && 
                        this.maze[newY][newX] === 1) {
                        neighbors.push({ x: newX, y: newY });
                    }
                });
                
                return neighbors;
            }
            
            setupInput() {
                document.addEventListener('keydown', (e) => {
                    if (this.keys[e.key]) return; // Prevent key repeat
                    
                    this.keys[e.key] = true;
                    let moved = false;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                            if (this.canMoveTo(this.player.x, this.player.y - 1)) {
                                this.player.y--;
                                moved = true;
                            }
                            break;
                        case 'ArrowDown':
                            if (this.canMoveTo(this.player.x, this.player.y + 1)) {
                                this.player.y++;
                                moved = true;
                            }
                            break;
                        case 'ArrowLeft':
                            if (this.canMoveTo(this.player.x - 1, this.player.y)) {
                                this.player.x--;
                                moved = true;
                            }
                            break;
                        case 'ArrowRight':
                            if (this.canMoveTo(this.player.x + 1, this.player.y)) {
                                this.player.x++;
                                moved = true;
                            }
                            break;
                    }
                    
                    if (moved) {
                        this.moves++;
                        this.createMoveParticles();
                        
                        // Check if reached exit
                        if (this.player.x === this.exit.x && this.player.y === this.exit.y) {
                            this.nextLevel();
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
            }
            
            canMoveTo(x, y) {
                return x >= 0 && x < this.MAZE_SIZE && 
                       y >= 0 && y < this.MAZE_SIZE && 
                       this.maze[y][x] === 0;
            }
            
            createMoveParticles() {
                for (let i = 0; i < 5; i++) {
                    this.particles.push({
                        x: this.MARGIN + this.player.x * this.CELL_SIZE + this.CELL_SIZE / 2,
                        y: this.MARGIN + this.player.y * this.CELL_SIZE + this.CELL_SIZE / 2,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 15,
                        color: '#00ff88'
                    });
                }
            }
            
            nextLevel() {
                const timeBonus = Math.max(0, 60 - Math.floor((Date.now() - this.startTime) / 1000)) * 10;
                const moveBonus = Math.max(0, 200 - this.moves) * 5;
                
                alert(`Level ${this.level} Complete!\nTime: ${Math.floor((Date.now() - this.startTime) / 1000)}s\nMoves: ${this.moves}\nBonus: ${timeBonus + moveBonus}`);
                
                this.level++;
                this.player.x = 1;
                this.player.y = 1;
                this.moves = 0;
                this.startTime = Date.now();
                this.generateMaze();
                
                // Create celebration particles
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        x: this.MARGIN + this.exit.x * this.CELL_SIZE + this.CELL_SIZE / 2,
                        y: this.MARGIN + this.exit.y * this.CELL_SIZE + this.CELL_SIZE / 2,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 30,
                        color: Math.random() > 0.5 ? '#ffff00' : '#ff6666'
                    });
                }
            }
            
            update() {
                // Update particles
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    return p.life > 0;
                });
                
                this.updateDisplay();
            }
            
            render() {
                this.ctx.fillStyle = '#000011';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw maze
                for (let y = 0; y < this.MAZE_SIZE; y++) {
                    for (let x = 0; x < this.MAZE_SIZE; x++) {
                        const cellX = this.MARGIN + x * this.CELL_SIZE;
                        const cellY = this.MARGIN + y * this.CELL_SIZE;
                        
                        if (this.maze[y][x] === 1) {
                            // Wall
                            this.ctx.fillStyle = '#0066aa';
                            this.ctx.fillRect(cellX, cellY, this.CELL_SIZE, this.CELL_SIZE);
                        } else {
                            // Path
                            this.ctx.fillStyle = '#001122';
                            this.ctx.fillRect(cellX, cellY, this.CELL_SIZE, this.CELL_SIZE);
                        }
                        
                        // Grid lines
                        this.ctx.strokeStyle = '#333333';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(cellX, cellY, this.CELL_SIZE, this.CELL_SIZE);
                    }
                }
                
                // Draw exit
                this.ctx.fillStyle = '#ffff00';
                this.ctx.fillRect(
                    this.MARGIN + this.exit.x * this.CELL_SIZE + 3,
                    this.MARGIN + this.exit.y * this.CELL_SIZE + 3,
                    this.CELL_SIZE - 6,
                    this.CELL_SIZE - 6
                );
                
                // Draw player
                this.ctx.fillStyle = '#00ff88';
                this.ctx.beginPath();
                this.ctx.arc(
                    this.MARGIN + this.player.x * this.CELL_SIZE + this.CELL_SIZE / 2,
                    this.MARGIN + this.player.y * this.CELL_SIZE + this.CELL_SIZE / 2,
                    this.CELL_SIZE / 2 - 4,
                    0, Math.PI * 2
                );
                this.ctx.fill();
                
                // Draw particles
                this.particles.forEach(p => {
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.life / 30;
                    this.ctx.fillRect(p.x - 1, p.y - 1, 3, 3);
                });
                this.ctx.globalAlpha = 1;
            }
            
            updateDisplay() {
                document.getElementById('level').textContent = this.level;
                document.getElementById('time').textContent = Math.floor((Date.now() - this.startTime) / 1000);
                document.getElementById('moves').textContent = this.moves;
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        new NeuralMazeEscape();
    </script>
</body>
</html>